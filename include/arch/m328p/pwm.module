--** Pulse width modulation for the ATmega328
-- @module pwm

#IF NOT (DEFINED (PWM.MODULE))
#DEFINE PWM.MODULE

INLINE PROC set16breg (VAL INT reg, VAL INT16 val)
  PLACED [MAX.PORT]BYTE ports 0:
  #PRAGMA DEFINED ports
  SEQ
    -- It looks like the high byte is always one greater than the low byte.
    -- This should be double-checked, but as an example:
    -- OCR1A = OCR1AL
    -- OCR1AL + 1 = OCR1AH
    -- According to the datasheet, we have to write the high byte first.
    ports[reg+1] := (BYTE (val >> 8)) 
    ports[reg] := (BYTE (val /\ #FF))
:

INT, INT, INT, INT FUNCTION pwm8.lookup (VAL INT pin)
  INT TCCRnA, TCCRnB, OCRnx:
  VALOF
    CASE pin
      5, 6
        SEQ
          TCCRnA := TCCR0A
          TCCRnB := TCCR0B
          IF
            pin = 6
              SEQ
                TCCRnA.bits := BV (WGM00) \/ BV (COM0A1)
                OCRnx := OCR0A
            TRUE --pin = 5
              SEQ
                TCCRnA.bits := BV (WGM00) \/ BV (COM0B1)
                OCRnx := OCR0B
      9, 10
        SEQ
          TCCRnA := TCCR1A
          TCCRnB := TCCR1B
          IF
            pin = 9
              SEQ
                TCCRnA.bits := BV (WGM10) \/ BV (COM1A1)
                OCRnx := OCR1A
            TRUE --pin = 10
              SEQ
                TCCRnA.bits := BV (WGM10) \/ BV (COM1B1)
                OCRnx := OCR1B
      3, 11
        SEQ
          TCCRnA := TCCR2A
          TCCRnB := TCCR2B
          IF
            pin = 11
              SEQ
                TCCRnA.bits := BV (WGM20) \/ BV (COM2A1)
                OCRnx := OCR2A
            TRUE --pin = 3
              SEQ
                TCCRnA.bits := BV (WGM20) \/ BV (COM2B1)
                OCRnx := OCR2B
      ELSE
        die ("The Arduino only supports 8-bit PWM on pins 3,5,6,9,10 and 11.")
    RESULT TCCRnA, TCCRnB, TCCRnA.bits, OCRnx
:

INT, INT, INT, INT FUNCTION pwm16.lookup (VAL INT pin)
  INT TCCRnA, TCCRnB, TCCRnA.bits, OCRnx:
  VALOF
    SEQ
      TCCRnA := TCCR1A
      TCCRnB := TCCR1B
      IF
        pin = 9
          SEQ
            TCCRnA.bits := BV (COM1A1)
            OCRnx := OCR1A
        pin = 10
          SEQ
            TCCRmA.bits := BV (COM1B1)
            OCRnx := OCR1B
        TRUE
          die ("The Arduino only supports 16-bit PWM on pins 9 and 10.")
  RESULT TCCRnA, TCCRnB, TCCRnA.bits, OCRnx
:

INT FUNCTION pwm8.TCCRnB.helper (VAL INT prescale)
  INT bits:
  VALOF
    CASE prescale
      0
        bits := 1 -- := BV (CSn0)
      8
        bits := 2 -- := BV (CSn1)
      64
        bits := 3 -- := BV (CSn0) \/ BV (CSn1)
      256
        bits := 4 -- := BV (CSn2)
      1024
        bits := 5 -- := BV (CSn2) \/ BV (CSn0)
      ELSE
        die ("Invalid clock prescale value")
  RESULT bits
:

INT FUNCTION pwm16.TCCRnB.helper (VAL INT prescale)
  INT bits:
  VALOF
    CASE prescale
      0
        bits := BV (WGM13) \/ 1 -- := BV (CSn0)
      8
        bits := BV (WGM13) \/ 2 -- := BV (CSn1)
      64
        bits := BV (WGM13) \/ 3 -- := BV (CSn0) \/ BV (CSn1)
      256
        bits := BV (WGM13) \/ 4 -- := BV (CSn2)
      1024
        bits := BV (WGM13) \/ 5 -- := BV (CSn2) \/ BV (CSn0)
      ELSE
        die ("Invalid clock prescale value")
  RESULT bits
:

INT FUNCTION pwm8.compare.lookup (VAL INT pin)
  INT OCRnx:
  VALOF
    CASE pin
      3
        OCRnx := OCR2B
      5
        OCRnx := OCR0B
      6
        OCRnx := OCR0A
      9
        OCRnx := OCR1A
      10
        OCRnx := OCR1B
      11
        OCRnx := OCR2A
      ELSE
        die ("The Arduino only supports 8-bit PWM on pins 3,5,6,9,10 and 11.")
  RESULT OCRnx
:

INT FUNCTION pwm16.compare.lookup (VAL INT pin)
  INT OCRnx:
  VALOF
    IF
      pin = 9
        OCRnx := OCR1A
      pin = 10
        OCRnx := OCR1B
      ELSE
        die ("The Arduino only supports 16-bit PWM on pins 9 and 10.")
  RESULT OCRnx
:



PROC pwm8.setup (VAL INT pin, prescale)
  INITIAL INT TCCRnA, TCCRnB, TCCRnA.bits, OCRnx IS pwm8.lookup (pin):
  INITIAL INT TCCRnB.bits IS pwm8.TCCRnB.helper (prescale):

  SEQ
    --digital.mode (pin, OUTPUT)
    -- This is simplest to call from a level up, honestly, let the user do it.
    --  To automate it here would involve reinventing the logic of digital.mode
    --  for every possible PWM pin, which, on the Mega, would be a royal pain.
    ports[TCCRnA] := ports[TCCRnA] \/ TCCRnA.bits
    ports[TCCRnB] := ports[TCCRnB] \/ TCCRnB.bits
    ports[OCRnx]  := 0
:

PROC pwm16.setup (VAL INT pin, prescale)
  INITIAL INT TCCRnA, TCCRnB, TCCRnA.bits, OCRnx IS pwm16.lookup (pin):
  INITIAL INT TCCRnB.bits IS pwm16.TCCRnB.helper (prescale):

  SEQ
    --digital.mode (pin, OUTPUT)
    ports[TCCRnA] := ports[TCCRnA] \/ TCCRnA.bits
    ports[TCCRnB] := ports[TCCRnB] \/ TCCRnB.bits
    ports[OCRnx]  := 0
:

PROC pwm8.set.compare (VAL INT pin, VAL BYTE level)
  INITIAL INT OCRnx IS pwm8.compare.lookup (pin):
  ports[OCRnx] := level
:

PROC pwm16.set.compare (VAL INT pin, VAL INT16 level)
  INITIAL INT OCRnx IS pwm16.compare.lookup (pin):
  -- Not sure if this is the way to do it...
  -- Not sure if I'm a fan of relying on the highs being one up from the lows..
  set16breg (OCRnx, level)
:



#IF FALSE
--These are (probably) deprecated methods. I'm leaving them so I have them for
-- reference when I find out how not-deprecated they are.



--{{{  PROC beginAnalog
--* Initialize analog input.
-- Only works on PWM pins. 
-- @param pin The Arduino pin number.
PROC beginAnalog (VAL INT pin)
  --Begins PWM for an 8 bit timer.
  PLACED [MAX.PORT]BYTE ports 0:
  #PRAGMA DEFINED ports

  INITIAL INT index IS ARDUINO.PIN.MAP[pin]:
  -- Double-lookup tables are a gross way of doing this..
  -- I'm not 100% on how it should be done, but if we just look up the constants
  --  depending on a case w/ and element per PWM pin, we can easily add
  --  saftey-checking when we get around to it... Maybe...

--Signalize that TCNT1 has reached
  --I think this sowed up randomly in a crash... Not gonna kill it yet though..
  SEQ
    -- FIXME: So, we need to set this to OUTPUT, but pinMode is part of wiring.
    --  Honstely not sure how to rectify this...
    --pinMode (pin, OUTPUT)

    -- Here WGM sets the mode to PWM, phase correct, TOP=0xFF (perhaps
    --  should change to TOP=OCRAn?) (pg. 109,137,161)
    -- COM sets the behavior of OCxn (the output pin connected to the given
    --  timer, OCRxn compare and ICRn TOP (if applicable))
    ports[TCR.MODE[index]] := ports[TCR.MODE[index]] \/ (BV (COM[index]) \/ BV (WGM[index]))


    -- Set prescale to 64... don't change that. The VM is using that
    --  for TCCR2, and we'll (for the moment) use the same everywhere.
    --  It should be noted that for some timers, CS1[index] and CS0[index]
    --  are the same bit...
    ports[TCR.PRESCALE[index]] := BV(CS1[index]) \/ BV(CS0[index])

    -- This justs sets the compare number to 0. It's really just a saftey thing.
    ports[OCR[index]] := 0
:
--}}}

--{{{  PROC analogWrite
--* Write an analog value to a pin.
-- @param pin The Arduino pin number.
-- @param level A [@code BYTE] representing the analog level (0 -> 255)
PROC analogWrite (VAL INT pin, VAL BYTE level)
  PLACED [MAX.PORT]BYTE ports 0:
  #PRAGMA DEFINED ports
  INITIAL INT index IS ARDUINO.PIN.MAP[pin]:
  SEQ
    ports[OCR[index]] := level
:
--}}}

--{{{  PROC endAnalog
--* Disable analog output on Arduino.
-- Only works on PWM pins.
-- @param pin The Arduino pin number.
PROC endAnalog (VAL INT pin)
  PLACED [MAX.PORT]BYTE ports 0:
  #PRAGMA DEFINED ports
  INITIAL INT index IS ARDUINO.PIN.MAP[pin]:
  SEQ
    ports[TCR.MODE[index]] := ports[TCR.MODE[index]] /\ (~ BV(COM[index]))
:
--}}}

-- FIXME: I'm thinking the only pins that can queue into the 16 bit
--  timer are 9 and 10... Can they run simultaniously? Yes. Yes they can.

INLINE PROC set16breg (VAL INT reg, VAL INT16 val)
  PLACED [MAX.PORT]BYTE ports 0:
  #PRAGMA DEFINED ports
  SEQ
    -- It looks like the high byte is always one greater
    -- than the low byte. For example:
    -- OCR1A = OCR1AL
    -- OCR1AL + 1 = OCR1AH
    -- According to the datasheet, we have to write the high byte first.
    ports[reg+1] := (BYTE (val >> 8)) 
    ports[reg] := (BYTE (val BITAND #FF))
:

-- Pin can only be 9 or 10
PROC beginAnalog16 (VAL INT pin)
  PLACED [MAX.PORT]BYTE ports 0:
  #PRAGMA DEFINED ports
  SEQ
    --pinMode (pin, OUTPUT)
    --CS10 sets the prescale to 8.
    ports[TCCR1B] := BV (WGM13) \/ BV (CS10)
    IF
      pin = 9
        SEQ
          ports[TCCR1A] := ports[TCCR1A] \/ BV (COM1A1)
          ports[OCR1A] := 0
      pin = 10
        SEQ
          ports[TCCR1A] := ports[TCCR1A] \/ BV (COM1B1)
          ports[OCR1B] := 0
      TRUE
        SKIP
:

PROC analogWrite16 (VAL INT pin, VAL INT16 level)
  PLACED [MAX.PORT]BYTE ports 0:
  #PRAGMA DEFINED ports
  IF
    pin = 9
      set16breg (OCR1A, level)
    pin = 10
      set16breg (OCR1B, level)
    TRUE
      SKIP
:

#ENDIF

#ENDIF
