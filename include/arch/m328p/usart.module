--** USART/serial routines for the ATmega328
-- @module usart

#IF NOT (DEFINED (USART.MODULE))
#DEFINE USART.MODULE

--FIXME: This is a helper method I'm not comfortable putting in plumbing. I just want something that takes care of the whole baud setup though, so I'm throwing it here in the 328 specific stuffs. Maybe there should be a constant?
PROC start.serial ()
  serial.setup (0, 57600)
:

--{{{  PROC beginSerialInerrupt
--* Initialize iterrupt-driven serial IO for port7.
-- Because the Arduino only has one serial port,
-- [@code port] is, in this case, a passthrough.
--
--
-- @param port Passthrough val for the serial port.
-- @param baud Baud rate.
PROC serial.setup (VAL INT port, VAL INT32 baud)
  VAL INT32 factor IS (((F.CPU / 16) + (baud / 2)) / baud) - 1:
  VAL [4]BYTE factor.bytes RETYPES factor:

  PLACED [MAX.PORT]BYTE ports 0:
  SEQ
    ports[UBRR0H] := factor.bytes[1]
    ports[UBRR0L] := factor.bytes[0]

    ports[UCSR0C] := 3 << UCSZ00
              -- This is the same as := UCSZ00 \/ UCSZ01
    ports[UCSR0B] := BV (TXEN0) \/ BV (RXEN0)
:
--}}}

--{{{  PROC serial.write
--* Write a byte to the serial port. (iterrupt driven) 
-- Because the Arduino only has one serial port,
-- [@code port] is, in this case, a passthrough.
--
-- @param port Passthrough val for the serial port.
-- @param b Byte to be written.
PROC serial.write.byte (VAL INT port, VAL BYTE b)
  PLACED [MAX.PORT]BYTE ports 0:
  #PRAGMA DEFINED ports
  SEQ
    IF
      (ports[UCSR0A] /\ BV (UDRE0)) = 0
        --{{{  transmit buffer full; wait for it to empty
        SEQ
          -- Enable the interrupt; UDRIE0 will be cleared by the (C-side)
          -- interrupt handler.
          ports[UCSR0B] := ports[UCSR0B] \/ BV (UDRIE0)
          INT dummy:
          wait.for.interrupt (VINTR.USART.UDRE, dummy)
        --}}}
      TRUE
        SKIP
    ports[UDR0] := b
:
--}}}

--{{{  PROC serial.read
--* Read a byte from the serial port. 
-- Because the Arduino only has one serial port,
-- [@code port] is, in this case, a passthrough.
--
-- @param port Passthrough val for the serial port.
-- @param b Byte to be read.
PROC serial.read.byte (VAL INT port, RESULT BYTE b)
  PLACED [MAX.PORT]BYTE ports 0:
  #PRAGMA DEFINED ports
  SEQ
    IF
      (ports[UCSR0A] /\ BV (RXC0)) = 0
        --{{{  receive buffer empty; wait for something to come in
        SEQ
          -- Enable the interrupt; RXCIE0 will be cleared by the (C-side)
          -- interrupt handler.
          ports[UCSR0B] := ports[UCSR0B] \/ BV (RXCIE0)
          INT dummy:
          wait.for.interrupt (VINTR.USART.RX, dummy)
        --}}}
      TRUE
        SKIP
    b := ports[UDR0]
:
--}}}

--{{{  PROC beginSerial
--* Initialize blocking driven serial IO for the serial port.
--
-- @param baud Baud rate
PROC serial.setup.blocking (VAL INT reg, VAL INT32 baud)
  VAL INT32 factor IS (((F.CPU / 16) + (baud / 2)) / baud) - 1:
  VAL [4]BYTE factor.bytes RETYPES factor:

  PLACED [MAX.PORT]BYTE ports 0:
  SEQ
    ports[UBRR0H] := factor.bytes[1]
    ports[UBRR0L] := factor.bytes[0]

    ports[UCSR0C] := 3 << UCSZ00
              --This is the same as := UCSZ00 \/ UCSZ01. 
    ports[UCSR0B] := BV (TXEN0)
:
--}}}

--{{{  PROC serialWrite
--* Write a string to the serial port. (blocking driven)
-- Because the Arduino only had one serial port,
-- port is, in this case, essentially a passthrough
--
-- @param port Passthrough val for the serial port
-- @param b Byte to be written
PROC serial.write.byte.blocking (VAL INT port, VAL BYTE b)
  PLACED [MAX.PORT]BYTE ports 0:
  #PRAGMA DEFINED ports
  SEQ
    WHILE (ports[UCSR0A] /\ BV (UDRE0)) = 0
      SKIP
    ports[UDR0] := b
:
--}}}

#ENDIF
