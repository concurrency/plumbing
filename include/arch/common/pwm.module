--** Common routines for configuring PWM on the ATmega family of processors.
-- @module pwm

#IF NOT (DEFINED (PWM.MODULE))
#DEFINE PWM.MODULE

-- FIXME MCJ
-- I would love to come up with a better naming convention
-- for the arch-specific part...
-- #INCLUDE "pwmarch.module" 
#INCLUDE "pwmmap.module" -- in platform

-- FIXME MCJ
-- "breg" sounds like "BREG" in the VM source.
-- The PROC can probably be named better.
INLINE PROC set16 (VAL INT reg, VAL INT16 val)
  PLACED [MAX.PORT]BYTE ports 0:
  #PRAGMA DEFINED ports
  SEQ
    -- It looks like the high byte is always one greater than the low byte.
    -- This should be double-checked, but as an example:
    -- OCR1A = OCR1AL
    -- OCR1AL + 1 = OCR1AH
    -- According to the datasheet, we have to write the high byte first.
    ports[reg+1] := (BYTE (val >> 8)) 
    ports[reg] := (BYTE (val BITAND #FF))
:

-- WARNING: The PWM pin must be set to output using a call like
--   digital.mode (pin, OUTPUT)
-- before it can be set up successfully as a PWM output.
-- This should not be an issue if using the higher-level wrapper of 
-- the PWM PROCs in this module.
PROC pwm8.setup (VAL INT pin, prescale)
  PLACED [MAX.PORT]BYTE ports 0:
  #PRAGMA DEFINED ports
  INITIAL INT TCCRnA, TCCRnB, OCRnx, BYTE TCCRnA.bit IS pwm8.lookup (pin):
  INITIAL BYTE TCCRnB.bits IS pwm8.TCCRnB.helper (prescale):

  SEQ
    -- FIXME 20100706 MCJ
    -- This is dangerous. The lookup returns an INT for the bitfield, but
    -- it should probably be a BYTE. We're downcasting here, and if something goes
    -- wrong, then we have an overflow...
    ports[TCCRnA] := ports[TCCRnA] \/ TCCRnA.bits
    ports[TCCRnB] := ports[TCCRnB] \/ TCCRnB.bits
    ports[OCRnx]  := 0
:

-- WARNING: The PWM pin must be set to output using a call like
--   digital.mode (pin, OUTPUT)
-- before it can be set up successfully as a PWM output.
-- This should not be an issue if using the higher-level wrapper of 
-- the PWM PROCs in this module.
PROC pwm16.setup (VAL INT pin, prescale)
  PLACED [MAX.PORT]BYTE ports 0:
  #PRAGMA DEFINED ports
  INITIAL INT TCCRnA, TCCRnB, OCRnx, BYTE TCCRnA.bits IS pwm16.lookup (pin):
  INITIAL BYTE TCCRnB.bits IS pwm16.TCCRnB.helper (prescale):

  SEQ
    ports[TCCRnA] := ports[TCCRnA] \/ TCCRnA.bits
    ports[TCCRnB] := ports[TCCRnB] \/ TCCRnB.bits
    ports[OCRnx]  := 0
:

PROC pwm8.set.compare (VAL INT pin, VAL BYTE level)
  PLACED [MAX.PORT]BYTE ports 0:
  #PRAGMA DEFINED ports
  INITIAL INT OCRnx IS pwm8.compare.lookup (pin):
  ports[OCRnx] := level
:

PROC pwm16.set.compare (VAL INT pin, VAL INT16 level)
  PLACED [MAX.PORT]BYTE ports 0:
  #PRAGMA DEFINED ports
  INITIAL INT OCRnx IS pwm16.compare.lookup (pin):
  -- Not sure if this is the way to do it...
  -- Not sure if I'm a fan of relying on the highs being one up from the lows..
  set16breg (OCRnx, level)
:

PROC pwm16.set.top (VAL INT pin, VAL INT16 top)
  INITIAL INT ICRn IS pwm16.IRCn.lookup (pin):
  set16 (ICRn, top)
:



#IF FALSE
--These are (probably) deprecated methods. I'm leaving them so I have them for
-- reference when I find out how not-deprecated they are.


--{{{  PROC beginAnalog
--* Initialize analog input.
-- Only works on PWM pins. 
-- @param pin The Arduino pin number.
PROC beginAnalog (VAL INT pin)
  --Begins PWM for an 8 bit timer.
  PLACED [MAX.PORT]BYTE ports 0:
  #PRAGMA DEFINED ports

  INITIAL INT index IS ARDUINO.PIN.MAP[pin]:
  -- Double-lookup tables are a gross way of doing this..
  -- I'm not 100% on how it should be done, but if we just look up the constants
  --  depending on a case w/ and element per PWM pin, we can easily add
  --  saftey-checking when we get around to it... Maybe...

--Signalize that TCNT1 has reached
  --I think this sowed up randomly in a crash... Not gonna kill it yet though..
  SEQ
    -- FIXME: So, we need to set this to OUTPUT, but pinMode is part of wiring.
    --  Honstely not sure how to rectify this...
    --pinMode (pin, OUTPUT)

    -- Here WGM sets the mode to PWM, phase correct, TOP=0xFF (perhaps
    --  should change to TOP=OCRAn?) (pg. 109,137,161)
    -- COM sets the behavior of OCxn (the output pin connected to the given
    --  timer, OCRxn compare and ICRn TOP (if applicable))
    ports[TCR.MODE[index]] := ports[TCR.MODE[index]] \/ (BV (COM[index]) \/ BV (WGM[index]))


    -- Set prescale to 64... don't change that. The VM is using that
    --  for TCCR2, and we'll (for the moment) use the same everywhere.
    --  It should be noted that for some timers, CS1[index] and CS0[index]
    --  are the same bit...
    ports[TCR.PRESCALE[index]] := BV(CS1[index]) \/ BV(CS0[index])

    -- This justs sets the compare number to 0. It's really just a saftey thing.
    ports[OCR[index]] := 0
:
--}}}

--{{{  PROC analogWrite
--* Write an analog value to a pin.
-- @param pin The Arduino pin number.
-- @param level A [@code BYTE] representing the analog level (0 -> 255)
PROC analogWrite (VAL INT pin, VAL BYTE level)
  PLACED [MAX.PORT]BYTE ports 0:
  #PRAGMA DEFINED ports
  INITIAL INT index IS ARDUINO.PIN.MAP[pin]:
  SEQ
    ports[OCR[index]] := level
:
--}}}

--{{{  PROC endAnalog
--* Disable analog output on Arduino.
-- Only works on PWM pins.
-- @param pin The Arduino pin number.
PROC endAnalog (VAL INT pin)
  PLACED [MAX.PORT]BYTE ports 0:
  #PRAGMA DEFINED ports
  INITIAL INT index IS ARDUINO.PIN.MAP[pin]:
  SEQ
    ports[TCR.MODE[index]] := ports[TCR.MODE[index]] /\ (~ BV(COM[index]))
:
--}}}

-- FIXME: I'm thinking the only pins that can queue into the 16 bit
--  timer are 9 and 10... Can they run simultaniously? Yes. Yes they can.

INLINE PROC set16breg (VAL INT reg, VAL INT16 val)
  PLACED [MAX.PORT]BYTE ports 0:
  #PRAGMA DEFINED ports
  SEQ
    -- It looks like the high byte is always one greater
    -- than the low byte. For example:
    -- OCR1A = OCR1AL
    -- OCR1AL + 1 = OCR1AH
    -- According to the datasheet, we have to write the high byte first.
    ports[reg+1] := (BYTE (val >> 8)) 
    ports[reg] := (BYTE (val BITAND #FF))
:

-- Pin can only be 9 or 10
PROC beginAnalog16 (VAL INT pin)
  PLACED [MAX.PORT]BYTE ports 0:
  #PRAGMA DEFINED ports
  SEQ
    --pinMode (pin, OUTPUT)
    --CS10 sets the prescale to 8.
    ports[TCCR1B] := BV (WGM13) \/ BV (CS10)
    IF
      pin = 9
        SEQ
          ports[TCCR1A] := ports[TCCR1A] \/ BV (COM1A1)
          ports[OCR1A] := 0
      pin = 10
        SEQ
          ports[TCCR1A] := ports[TCCR1A] \/ BV (COM1B1)
          ports[OCR1B] := 0
      TRUE
        SKIP
:

PROC analogWrite16 (VAL INT pin, VAL INT16 level)
  PLACED [MAX.PORT]BYTE ports 0:
  #PRAGMA DEFINED ports
  IF
    pin = 9
      set16breg (OCR1A, level)
    pin = 10
      set16breg (OCR1B, level)
    TRUE
      SKIP
:
#ENDIF

#ENDIF
