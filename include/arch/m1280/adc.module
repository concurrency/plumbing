--** ACD routines for the 1280
-- @module adc

#IF NOT (DEFINED (ADC.MODULE))
#DEFINE ADC.MODULE

--* This value is used for calculating analog channel choice in adc.module
-- The AVR analog pins start at (AVR) pin 82 (A15) and move to 97 (A0).
VAL INT AVR.A0 IS 97:

--* Perform an Analog-to-Digital Conversino on the given AVR pin, and write
-- out the result.
-- @param avr.pin The [@em AVR pin] on which to perfom the ADC.
-- @param USE.VCC Set by the helper functions (probably). Whether or not to
--   use the internal voltage reference, or the aref pin as a reference.
--   WARNING drew 20100713 Is there only one AREF pin on the Mega boards?
-- @param v The INT that will be used to store the analog read.
PROC adc.base (VAL INT avr.pin, VAL BOOL USE.VCC, RESULT INT v)
  PLACED [MAX.PORT]BYTE ports 0:
  #PRAGMA DEFINED ports
  INT16 result:
  -- AVR pins for Analog start at pin 97 and move down.
  INITIAL INT a.pin IS (avr.pin - AVR.A0) * (-1):
  SEQ
    -- Enable ADC; enable interrupt; clock prescale 128
    -- The '7' is == ADPS2 \/ ADPS1 \/ ADPS0 which sest the prescale to 128
    ports[ADCSRA] := (BV (ADEN) \/ BV (ADIE)) \/ 7
    -- Disable digital inputs on the ADC pin.
    IF
      a.pin < 8
        ports[DIDR0] := ports[DIDR0] \/ BV (a.pin)
      TRUE
        ports[DIDR2] := ports[DIDR2] \/ BV (a.pin -8)

    -- Select the channel
    IF
      a.pin < 8
        ports[ADMUX] := (BYTE a.pin)
      TRUE
        SEQ
          ports[ADMUX] := (BYTE (a.pin - 8))
          ports[ADCSRB] := BV (MUX5)
    -- If we are using Vcc as out reference, set bit REFS0
    IF
      USE.VCC
        ports[ADMUX] := ports[ADMUX] \/ BV (REFS0)
      TRUE
        --FIXME: Should this be a skip? It's not symetircal with the 328,
        -- and having never tested the aref pins on either the Doomduino nor
        -- any in the mega line, I've no idea if this is right...
        SKIP

    -- Start conversion
    ports[ADCSRA] := ports[ADCSRA] \/ BV (ADSC)
    WHILE ((ports[ADCSRA] /\ BV(ADSC)) = BV (ADSC))
      SKIP

    -- Read value
    -- (We can't do this by retyping ports, since that does a 16-bit read)
    [2]BYTE bytes RETYPES result:
    bytes[0], bytes[1] := ports[ADCL], ports[ADCH]

    v := (INT result)
:

--* Helper function for performing an ADC using the AREF.
-- @param avr.pin The [@em AVR pin] on which to perfom the ADC.
-- @param v The INT that will be used to store the analog read.
INLINE PROC adc.aref (VAL INT pin, RESULT INT v)
  adc.base (pin, FALSE, v)
:

--* Helper function for performing an ADC using the VCC.
-- @param avr.pin The [@em AVR pin] on which to perfom the ADC.
-- @param v The INT that will be used to store the analog read.
INLINE PROC adc.vcc (VAL INT pin, RESULT INT v)
  adc.base (pin, TRUE, v)
:

#ENDIF
