--** Input/output routines for the ATmega1280 series.
-- @module io

#IF NOT (DEFINED (IO.MODULE))
#DEFINE IO.MODULE

#INCLUDE "avr.module"
#INCLUDE "base.module"

PROC adc.io (VAL INT pin, RESULT INT v)
  PLACED [MAX.PORT]BYTE ports 0:
  INT16 result:
  SEQ
    -- Enable ADC; enable interrupt; clock prescale 128
    ports[ADCSRA] := (BV (ADEN) \/ BV (ADIE)) \/ BV (ADPS0)
    -- Disable digital inputs on all 16 ADC pins.
    -- FIXME: Seems a bit much? Perhaps we should pinpoint which pin to switch?
    ports[DIDR0] := #3F
    ports[DIDR2] := #3F

    -- Select the channel
    IF
      pin < 8
        ports[ADMUX] := BV (REFS0) \/ (BYTE pin)
      TRUE
        SEQ
          ports[ADMUX] := BV (REFS0) \/ (BYTE (pin - 8))
          ports[ADCSRB] := BV (MUX5)

    -- Start conversion
    ports[ADCSRA] := ports[ADCSRA] \/ BV (ADSC)
    WHILE ((ports[ADCSRA] /\ BV(ADSC)) = BV (ADSC))
      SKIP

    -- Read value
    -- (We can't do this by retyping ports, since that does a 16-bit read)
    [2]BYTE bytes RETYPES result:
    bytes[0], bytes[1] := ports[ADCL], ports[ADCH]

    v := (INT result)
:

-- CONSTANT ARRAYS
-- Because we are working with multiple serial ports, we place
-- all of the critical registers into arrays that can be indexed
-- by the serial port... 0, 1, 2, or 3

-- Baud Rate Registers (low/high bites)
VAL []INT UBRRL IS [UBRR0L, UBRR1L, UBRR2L, UBRR3L]:
VAL []INT UBRRH IS [UBRR0H, UBRR1H, UBRR2H, UBRR3H]:
-- UCSR -- Control and status register
VAL []INT UCSRC IS [UCSR0C, UCSR1C, UCSR2C, UCSR3C]:
VAL []INT UCSRB IS [UCSR0B, UCSR1B, UCSR2B, UCSR3B]:
VAL []INT UCSRA IS [UCSR0A, UCSR1A, UCSR2A, UCSR3A]:

VAL []INT UDRE IS [UDRE0, UDRE1, UDRE2, UDRE3]:
VAL []INT UDR  IS [UDR0, UDR1, UDR2, UDR3]:

VAL []INT UDRIE IS [UDRIE0, UDRIE1, UDRIE2, UDRIE3]:
VAL []INT VINTR.UDRE IS [VINTR.USART.UDRE0, VINTR.USART.UDRE1, VINTR.USART.UDRE2, VINTR.USART.UDRE3]:

VAL []INT TXEN IS [TXEN0, TXEN1, TXEN2, TXEN3]:
VAL []INT RXEN IS [RXEN0, RXEN1, RXEN2, RXEN3]:

VAL []INT UCSZ IS [UCSZ00, UCSZ10, UCSZ20, UCSZ30]:

VAL []INT RXC IS [RXC0, RXC1, RXC2, RXC3]:
VAL []INT RXCIE IS [RXCIE0, RXCIE1, RXCIE2, RXCIE3]:
VAL []INT VINTR.RX IS [VINTR.USART.RX0, VINTR.USART.RX1, VINTR.USART.RX2, VINTR.USART.RX3]:

-- BLOCKING SERIAL PROCEDURES
-- These PROCs implement blocking reads and writes on the serial ports.

--* Initialise the serial port.
--  Although it takes an additional parameter on the 1280, this
--  takes its naming from the Wiring library. It sets up for blocking use
--  of the serial port.
-- @param port Serial port (0, 1, 2, or 3)
-- @param baud Baud rate
PROC beginSerial.blocking (VAL INT reg, VAL INT32 baud)
  VAL INT32 factor IS (((F.CPU / 16) + (baud / 2)) / baud) - 1:
  VAL [4]BYTE factor.bytes RETYPES factor:
  PLACED [MAX.PORT]BYTE ports 0:
  #PRAGMA DEFINED ports
  SEQ
    ports[UBRRH[reg]] := factor.bytes[1]
    ports[UBRRL[reg]] := factor.bytes[0]

    ports[UCSRC[reg]] := 3 << UCSZ00
    ports[UCSRB[reg]] := BV (TXEN[reg])
:

--* Write a byte to the serial port (blocking).
--  Again, we use the Wiring naming convention for the blocking
--  write to the serial port.
-- @param VAL INT Serial port (0, 1, 2, or 3)
-- @param VAL BYTE Byte to write

PROC serialWriteByte.blocking (VAL INT reg, VAL BYTE b)
  PLACED [MAX.PORT]BYTE ports 0:
  #PRAGMA DEFINED ports
  SEQ
    WHILE (ports[UCSRA[reg]] /\ BV (UDRE[reg])) = 0
      SKIP
    ports[UDR[reg]] := b
:

-- INTERRUPT-DRIVEN SERIAL I/O PROCEDURES
-- These PROCs implement non-blocking, interrupt-driven serial I/O on 
-- each of the serial ports.

--* Initialise iterrupt-driven serial IO
-- @param port Serial port (0, 1, 2, or 3)
-- @param baud Baud rate
PROC serial.setup (VAL INT reg, VAL INT32 baud)
  VAL INT32 factor IS (((F.CPU / 16) + (baud / 2)) / baud) - 1:
  VAL [4]BYTE factor.bytes RETYPES factor:
  PLACED [MAX.PORT]BYTE ports 0:
  #PRAGMA DEFINED ports
  SEQ
    ports[UBRRH[reg]] := factor.bytes[1]
    ports[UBRRL[reg]] := factor.bytes[0]

    ports[UCSRC[reg]] := 3 << UCSZ[reg]
    ports[UCSRB[reg]] := BV (TXEN[reg]) \/ BV (RXEN[reg])
:

--* Write a byte to the serial port (interrupt-driven)
-- @param VAL INT Serial port (0, 1, 2, or 3)
-- @param VAL BYTE Byte to write
PROC serial.write.byte (VAL INT reg, VAL BYTE b)
  PLACED [MAX.PORT]BYTE ports 0:
  #PRAGMA DEFINED ports
  SEQ
    IF
      (ports[UCSRA[reg]] /\ BV (UDRE[reg])) = 0
        --{{{  transmit buffer full; wait for it to empty
        SEQ
          -- Enable the interrupt; UDRIE0 will be cleared by the (C-side)
          -- interrupt handler.
          ports[UCSRB[reg]] := ports[UCSRB[reg]] \/ BV (UDRIE[reg])
          INT dummy:
          wait.for.interrupt (VINTR.UDRE[reg], dummy)
        --}}}
      TRUE
        SKIP
    ports[UDR[reg]] := b
:

--{{{  PROC serialWriteInt
--* Write an [@code INT] to the serial port in hex.
-- @param n The integer to write.
PROC serial.write.int (VAL INT usart, VAL INT n)
  VAL []BYTE digits IS "0123456789abcdef":
  SEQ i = 3 FOR 4 STEP -1
    serial.write.byte (usart, digits[(n >> (i * 4)) /\ #F])
:
--}}}
--{{{  PROC serialWriteInt32
--* Write an [@code INT32] to the serial port in hex.
-- @param n The long integer ([@code INT32]) to write.
PROC serial.write.int32 (VAL INT usart, VAL INT32 n)
  VAL []BYTE digits IS "0123456789abcdef":
  SEQ i = 7 FOR 8 STEP -1
    serial.write.byte (usart, digits[INT ((n >> (i * 4)) /\ #F)])
:
--}}}
PROC serial.read.byte (VAL INT reg, RESULT BYTE b)
  PLACED [MAX.PORT]BYTE ports 0:
  #PRAGMA DEFINED ports
  SEQ
    IF
      -- FIXME: Again, this was RXC1?
      (ports[UCSRA[reg]] /\ BV (RXC[reg])) = 0
        --{{{  receive buffer empty; wait for something to come in
        SEQ
          -- Enable the interrupt; RXCIE0 will be cleared by the (C-side)
          -- interrupt handler. (FIXME: This was RXCIE1... for port zero? Was that wrong?)
          ports[UCSRB[reg]] := ports[UCSRB[reg]] \/ BV (RXCIE[reg])
          INT dummy:
          wait.for.interrupt (VINTR.RX[reg], dummy)
        --}}}
      TRUE
        SKIP
    -- FIXME: This was UDR1?
    b := ports[UDR[reg]]
:

#ENDIF
