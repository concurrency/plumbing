#INCLUDE "avr.module"
#INCLUDE "base.module"

-- Note to self: this is the io.module for the 1280.

PROC adc.io (VAL INT pin, RESULT INT v)
  PLACED [MAX.PORT]BYTE ports 0:
  INT16 result:
  SEQ
    -- Enable ADC; enable interrupt; clock prescale 128
    ports[ADCSRA] := (BV (ADEN) \/ BV (ADIE)) \/ BV (ADPS0)
    -- Disable digital inputs on all 16 ADC pins.
    -- FIXME: Seems a bit much? Perhaps we should pinpoint which pin to switch?
    ports[DIDR0] := #3F
    ports[DIDR2] := #3F

    -- Select the channel
    IF
      pin < 8
        ports[ADMUX] := BV (REFS0) \/ (BYTE pin)
      TRUE
        SEQ
          ports[ADMUX] := BV (REFS0) \/ (BYTE (pin - 8))
          ports[ADCSRB] := BV (MUX5)

    -- Start conversion
    ports[ADCSRA] := ports[ADCSRA] \/ BV (ADSC)
    WHILE ((ports[ADCSRA] /\ BV(ADSC)) = BV (ADSC))
      SKIP

    -- Read value
    -- (We can't do this by retyping ports, since that does a 16-bit read)
    [2]BYTE bytes RETYPES result:
    bytes[0], bytes[1] := ports[ADCL], ports[ADCH]

    v := (INT result)
:


-- STUFF FOR SERIAL PORT 0
--* Initialise the serial port.
-- @param baud Baud rate
PROC serial.setup (VAL INT32 baud)
  VAL INT32 factor IS (((F.CPU / 16) + (baud / 2)) / baud) - 1:
  VAL [4]BYTE factor.bytes RETYPES factor:

  PLACED [MAX.PORT]BYTE ports 0:
  SEQ
    ports[UBRR0H] := factor.bytes[1]
    ports[UBRR0L] := factor.bytes[0]

    ports[UCSR0C] := 3 << UCSZ00
    ports[UCSR0B] := BV (TXEN0)
:
--* Initialise iterrupt-driven serial IO for port1.
--* Lifted from ledmatrix.occ
-- @param baud Baud rate
PROC serial.intr.setup (VAL INT32 baud)
  VAL INT32 factor IS (((F.CPU / 16) + (baud / 2)) / baud) - 1:
  VAL [4]BYTE factor.bytes RETYPES factor:

  PLACED [MAX.PORT]BYTE ports 0:
  SEQ
    ports[UBRR0H] := factor.bytes[1]
    ports[UBRR0L] := factor.bytes[0]

    ports[UCSR0C] := 3 << UCSZ00
    ports[UCSR0B] := BV (TXEN0) \/ BV (RXEN0)
:

--* Write a string to the serial port.
-- @param string Bytes to write
PROC serial.write (VAL BYTE b)
  PLACED [MAX.PORT]BYTE ports 0:
  #PRAGMA DEFINED ports
  SEQ
    WHILE (ports[UCSR0A] /\ BV (UDRE0)) = 0
      SKIP
    ports[UDR0] := b
:

PROC serial.intr.write (VAL BYTE b)
  PLACED [MAX.PORT]BYTE ports 0:
  #PRAGMA DEFINED ports
  SEQ
    IF
      (ports[UCSR0A] /\ BV (UDRE0)) = 0
        --{{{  transmit buffer full; wait for it to empty
        SEQ
          -- Enable the interrupt; UDRIE0 will be cleared by the (C-side)
          -- interrupt handler.
          ports[UCSR0B] := ports[UCSR0B] \/ BV (UDRIE0)
          INT dummy:
          wait.for.interrupt (VINTR.USART.UDRE, dummy)
        --}}}
      TRUE
        SKIP
    ports[UDR0] := b
:

PROC serial.intr.read (RESULT BYTE b)
  PLACED [MAX.PORT]BYTE ports 0:
  #PRAGMA DEFINED ports
  SEQ
    IF
      (ports[UCSR0A] /\ BV (RXC1)) = 0
        --{{{  receive buffer empty; wait for something to come in
        SEQ
          -- Enable the interrupt; RXCIE0 will be cleared by the (C-side)
          -- interrupt handler.
          ports[UCSR0B] := ports[UCSR1B] \/ BV (RXCIE1)
          INT dummy:
          wait.for.interrupt (VINTR.USART.RX, dummy)
        --}}}
      TRUE
        SKIP
    b := ports[UDR1]
:


-- STUFF FOR SERIAL PORT 1
--* Initialise the serial port.
-- @param baud Baud rate
PROC serial1.setup (VAL INT32 baud)
  VAL INT32 factor IS (((F.CPU / 16) + (baud / 2)) / baud) - 1:
  VAL [4]BYTE factor.bytes RETYPES factor:

  PLACED [MAX.PORT]BYTE ports 0:
  SEQ
    ports[UBRR1H] := factor.bytes[1]
    ports[UBRR1L] := factor.bytes[0]

    ports[UCSR1C] := 3 << UCSZ10
    ports[UCSR1B] := BV (TXEN1)
:
--* Initialise iterrupt-driven serial IO for port1.
--* Lifted from ledmatrix.occ
-- @param baud Baud rate
PROC serial1.intr.setup (VAL INT32 baud)
  VAL INT32 factor IS (((F.CPU / 16) + (baud / 2)) / baud) - 1:
  VAL [4]BYTE factor.bytes RETYPES factor:

  PLACED [MAX.PORT]BYTE ports 0:
  SEQ
    ports[UBRR1H] := factor.bytes[1]
    ports[UBRR1L] := factor.bytes[0]

    ports[UCSR1C] := 3 << UCSZ10
    ports[UCSR1B] := BV (TXEN1) \/ BV (RXEN1)
:

--* Write a string to the serial port.
-- @param string Bytes to write
PROC serial1.write (VAL BYTE b)
  PLACED [MAX.PORT]BYTE ports 0:
  #PRAGMA DEFINED ports
  SEQ
    WHILE (ports[UCSR1A] /\ BV (UDRE1)) = 0
      SKIP
    ports[UDR1] := b
:

PROC serial1.intr.write (VAL BYTE b)
  PLACED [MAX.PORT]BYTE ports 0:
  #PRAGMA DEFINED ports
  SEQ
    IF
      (ports[UCSR1A] /\ BV (UDRE1)) = 0
        --{{{  transmit buffer full; wait for it to empty
        SEQ
          -- Enable the interrupt; UDRIE0 will be cleared by the (C-side)
          -- interrupt handler.
          ports[UCSR1B] := ports[UCSR1B] \/ BV (UDRIE1)
          INT dummy:
          wait.for.interrupt (VINTR.USART.UDRE, dummy)
        --}}}
      TRUE
        SKIP
    ports[UDR1] := b
:

PROC serial1.intr.read (RESULT BYTE b)
  PLACED [MAX.PORT]BYTE ports 0:
  #PRAGMA DEFINED ports
  SEQ
    IF
      (ports[UCSR1A] /\ BV (RXC1)) = 0
        --{{{  receive buffer empty; wait for something to come in
        SEQ
          -- Enable the interrupt; RXCIE0 will be cleared by the (C-side)
          -- interrupt handler.
          ports[UCSR1B] := ports[UCSR1B] \/ BV (RXCIE1)
          INT dummy:
          wait.for.interrupt (VINTR.USART.RX, dummy)
        --}}}
      TRUE
        SKIP
    b := ports[UDR1]
:


-- STUFF FOR SERIAL PORT 2
--* Initialise the serial port.
-- @param baud Baud rate
PROC serial2.setup (VAL INT32 baud)
  VAL INT32 factor IS (((F.CPU / 16) + (baud / 2)) / baud) - 1:
  VAL [4]BYTE factor.bytes RETYPES factor:

  PLACED [MAX.PORT]BYTE ports 0:
  SEQ
    ports[UBRR2H] := factor.bytes[1]
    ports[UBRR2L] := factor.bytes[0]

    ports[UCSR2C] := 3 << UCSZ20
    ports[UCSR2B] := BV (TXEN2)
:
--* Initialise iterrupt-driven serial IO for port1.
--* Lifted from ledmatrix.occ
-- @param baud Baud rate
PROC serial2.intr.setup (VAL INT32 baud)
  VAL INT32 factor IS (((F.CPU / 16) + (baud / 2)) / baud) - 1:
  VAL [4]BYTE factor.bytes RETYPES factor:

  PLACED [MAX.PORT]BYTE ports 0:
  SEQ
    ports[UBRR2H] := factor.bytes[1]
    ports[UBRR2L] := factor.bytes[0]

    ports[UCSR2C] := 3 << UCSZ20
    ports[UCSR2B] := BV (TXEN2) \/ BV (RXEN2)
:

--* Write a string to the serial port.
-- @param string Bytes to write
PROC serial2.write (VAL BYTE b)
  PLACED [MAX.PORT]BYTE ports 0:
  #PRAGMA DEFINED ports
  SEQ
    WHILE (ports[UCSR2A] /\ BV (UDRE2)) = 0
      SKIP
    ports[UDR2] := b
:

PROC serial2.intr.write (VAL BYTE b)
  PLACED [MAX.PORT]BYTE ports 0:
  #PRAGMA DEFINED ports
  SEQ
    IF
      (ports[UCSR2A] /\ BV (UDRE2)) = 0
        --{{{  transmit buffer full; wait for it to empty
        SEQ
          -- Enable the interrupt; UDRIE0 will be cleared by the (C-side)
          -- interrupt handler.
          ports[UCSR2B] := ports[UCSR2B] \/ BV (UDRIE2)
          INT dummy:
          wait.for.interrupt (VINTR.USART.UDRE, dummy)
        --}}}
      TRUE
        SKIP
    ports[UDR2] := b
:

PROC serial2.intr.read (RESULT BYTE b)
  PLACED [MAX.PORT]BYTE ports 0:
  #PRAGMA DEFINED ports
  SEQ
    IF
      (ports[UCSR2A] /\ BV (RXC2)) = 0
        --{{{  receive buffer empty; wait for something to come in
        SEQ
          -- Enable the interrupt; RXCIE0 will be cleared by the (C-side)
          -- interrupt handler.
          ports[UCSR2B] := ports[UCSR2B] \/ BV (RXCIE2)
          INT dummy:
          wait.for.interrupt (VINTR.USART.RX, dummy)
        --}}}
      TRUE
        SKIP
    b := ports[UDR2]
:


-- STUFF FOR SERIAL PORT 3
--* Initialise the serial port.
-- @param baud Baud rate
PROC serial3.setup (VAL INT32 baud)
  VAL INT32 factor IS (((F.CPU / 16) + (baud / 2)) / baud) - 1:
  VAL [4]BYTE factor.bytes RETYPES factor:

  PLACED [MAX.PORT]BYTE ports 0:
  SEQ
    ports[UBRR3H] := factor.bytes[1]
    ports[UBRR3L] := factor.bytes[0]

    ports[UCSR3C] := 3 << UCSZ30
    ports[UCSR3B] := BV (TXEN3)
:
--* Initialise iterrupt-driven serial IO for port1.
--* Lifted from ledmatrix.occ
-- @param baud Baud rate
PROC serial3.intr.setup (VAL INT32 baud)
  VAL INT32 factor IS (((F.CPU / 16) + (baud / 2)) / baud) - 1:
  VAL [4]BYTE factor.bytes RETYPES factor:

  PLACED [MAX.PORT]BYTE ports 0:
  SEQ
    ports[UBRR3H] := factor.bytes[1]
    ports[UBRR3L] := factor.bytes[0]

    ports[UCSR3C] := 3 << UCSZ30
    ports[UCSR3B] := BV (TXEN3) \/ BV (RXEN3)
:

--* Write a string to the serial port.
-- @param string Bytes to write
PROC serial3.write (VAL BYTE b)
  PLACED [MAX.PORT]BYTE ports 0:
  #PRAGMA DEFINED ports
  SEQ
    WHILE (ports[UCSR3A] /\ BV (UDRE3)) = 0
      SKIP
    ports[UDR3] := b
:

PROC serial3.intr.write (VAL BYTE b)
  PLACED [MAX.PORT]BYTE ports 0:
  #PRAGMA DEFINED ports
  SEQ
    IF
      (ports[UCSR3A] /\ BV (UDRE3)) = 0
        --{{{  transmit buffer full; wait for it to empty
        SEQ
          -- Enable the interrupt; UDRIE0 will be cleared by the (C-side)
          -- interrupt handler.
          ports[UCSR3B] := ports[UCSR3B] \/ BV (UDRIE3)
          INT dummy:
          wait.for.interrupt (VINTR.USART.UDRE, dummy)
        --}}}
      TRUE
        SKIP
    ports[UDR3] := b
:

PROC serial3.intr.read (RESULT BYTE b)
  PLACED [MAX.PORT]BYTE ports 0:
  #PRAGMA DEFINED ports
  SEQ
    IF
      (ports[UCSR3A] /\ BV (RXC3)) = 0
        --{{{  receive buffer empty; wait for something to come in
        SEQ
          -- Enable the interrupt; RXCIE0 will be cleared by the (C-side)
          -- interrupt handler.
          ports[UCSR3B] := ports[UCSR3B] \/ BV (RXCIE3)
          INT dummy:
          wait.for.interrupt (VINTR.USART.RX, dummy)
        --}}}
      TRUE
        SKIP
    b := ports[UDR3]
:
