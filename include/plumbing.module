--** The Plumbing library.
--
-- [@code PROC]s in this module generally have arguments in this order:
--
-- [@item] non-channels;
-- [@item] input channels;
-- [@item] output channels.
--
-- @module plumbing

#IF NOT (DEFINED (PLUMBING.MODULE))
#DEFINE PLUMBING.MODULE

#INCLUDE "avr.module"
#INCLUDE "boardmap.module"
#INCLUDE "printing.module"
#INCLUDE "servo.module"

--{{{ Constants
DATA TYPE LEVEL IS INT:
VAL LEVEL LOW IS #0:
VAL LEVEL HIGH IS #1:

VAL INT INPUT IS #0:
VAL INT OUTPUT IS #1:

VAL BOOL VCC IS TRUE:
VAL BOOL AREF IS FALSE:

VAL INT DEBOUNCE.TIME IS 50:
--}}}


--{{{ PROC digital.write
--* Sets the digitial state of a pin to either HIGH or LOW.
-- @param board.pin The board pin to be set.
-- @param state The state to set -- Either HIGH or LOW.
PROC digital.write (VAL INT board.pin, state)
  INITIAL INT avr.pin IS board.to.chip(board.pin):
  --INT r.ddr, r.port, r.pin, bit:
  INT dummy1, r.port, dummy2, bit
  SEQ
    --r.ddr, r.port, r.pin, bit := chip.to.gpio (avr.pin)
    dummy1, r.port, dummy2, bit := chip.to.gpio (avr.pin)
    pin.write(r.port, bit, state)
:
--}}}

--{{{ PROC digital.read
--* Reads the digitial state of a pin. Either HIGH or LOW.
-- @param board.pin The board pin to be read.
-- @param state The pin's current state -- Either HIGH or LOW.
PROC digital.read (VAL INT board.pin, RESULT INT state)
  INITIAL INT avr.pin IS board.to.chip(board.pin):
  --INT r.ddr, r.port, r.pin, bit:
  INT dummy1, dummy2, r.pin, bit:
  SEQ
    --r.ddr, r.port, r.pin, bit := chip.to.gpio (avr.pin)
    dummy1, dummy2, r.pin, bit := chip.to.gpio (avr.pin)
    pin.read(r.pin, bit, state)
:
--}}}

--{{{ PROC digital.mode
--* Sets the Data Direction Register of the given pin (sets the flow of data)
-- to either INPUT or OUTPUT.
-- @param board.pin The board pin to set the direction of.
-- @param mode The mode to be set. Either INPUT or OUTPUT.
PROC digital.mode (VAL INT board.pin, mode)
  INITIAL INT avr.pin IS board.to.chip(board.pin):
  --INT r.ddr, r.port, r.pin, bit:
  INT r.ddr, dummy1, dummy2, bit:
  SEQ
    --r.ddr, r.port, r.pin, bit := chip.to.gpio (avr.pin)
    r.ddr, dumm1, dummy2, bit := chip.to.gpio (avr.pin)
    pin.mode(r.ddr, bit, mode)
:
--}}}

--{{{ PROC digital.output
--* Set digital levels on a pin.
-- Reads LEVEL values (LOW or HIGH) on the input 
-- channel, and sets the value of the specified pin 
-- accordingly.
--
-- @param pin The Arduino pin number
-- @param in Pin levels (LOW or HIGH)
PROC digital.output (VAL INT board.pin, CHAN LEVEL in?)
  LEVEL v:
  SEQ
    in ? v
    digital.mode (board.pin, OUTPUT)
    WHILE TRUE
      SEQ
        digital.write (board.pin, INT v)
        in ? v
:
--}}}

--{{{ PROC debounce
--* Debounce a channel.
-- Debounces a channel of LEVELs. Specifically, if 
-- multiple values come in within the DEBOUNCE.TIME 
-- (currently 50ms), only the first value is passed through.
--
-- @param in The incoming LEVEL values
-- @param out The outgoing LEVEL values, debounced
PROC debounce (CHAN LEVEL in?, out!)
  LEVEL v:
  WHILE TRUE
    TIMER tim:
    INT t:
    SEQ
      in ? v
      tim ? t
      t := t PLUS DEBOUNCE.TIME
      INITIAL BOOL ignoring IS TRUE:
      WHILE ignoring
        ALT
          LEVEL any:
          in ? any
            SKIP
          tim ? AFTER t
            ignoring := FALSE
      out ! v
:
--}}}

--{{{ PROC level.to.signal
--* Convert a LEVEL to a SIGNAL.
-- Consumes a stream of LEVEL values, and emits a SIGNAL
-- for each LEVEL received, regardless of whether it is
-- LOW or HIGH.
--
-- @param in Input LEVEL values.
-- @param out Output SIGNALs.
PROC level.to.signal (CHAN LEVEL in?, CHAN SIGNAL out!)
  WHILE TRUE
    SEQ
      LEVEL any:
      in ? any
      out ! SIGNAL
:
--}}}

--{{{ PROC invert.level
--* Invert LEVELs.
-- Reads in LEVEL values, and outputs the opposite.
-- Upon receiving a LOW, sends a HIGH, and visa versa.
--
-- @param in Incoming LEVEL values.
-- @param out Outgoing LEVEL values, inverted.
PROC invert.level (CHAN LEVEL in?, out!)
  WHILE TRUE
    LEVEL v:
    SEQ
      in ? v
      IF
        v = HIGH
          out ! LOW
        TRUE -- If v = LOW
          out ! HIGH
:
--}}}

--{{{ PROC tick
--* Generates a consistent stream of SIGNALs.
-- Every [@code period] milliseconds, a SIGNAL is generated.
--
-- @param period A delay time in milliseconds.
-- @param out SIGNALs generated after the given delay.
PROC tick (VAL INT period, CHAN SIGNAL out!)
  WHILE TRUE
    SEQ
      delay (period)
      out ! SIGNAL
:
--}}}

--{{{ PROC toggle
--* Outputs an alternating stream of LEVEL values.
-- Starting with an initial level (either LOW or HIGH), this 
-- process outputs a stream of alternating LEVEL values upon 
-- request. On receiving a SIGNAL, the next LEVEL is emitted
--
-- @param initial.level Either LOW or HIGH to start.
-- @param in The request line.
-- @param out The alternating stream of LEVEL values.
PROC toggle (VAL LEVEL initial.level, CHAN SIGNAL in?, CHAN LEVEL out!)
  INITIAL LEVEL level IS initial.level:
  WHILE TRUE
    SEQ
      out ! level
      in ? SIGNAL
      IF
        level = HIGH
          level := LOW
        TRUE -- If level = LOW
          level := HIGH
:
--}}}

--{{{ PROC pin.toggle
--* Drives a pin alternately LOW and HIGH.
-- Upon request, alternates the level of a pin from LOW to HIGH.
-- 
-- @param pin The (digital) Arduino pin we want to drive.
-- @param initial.level Either LOW or HIGH.
-- @param in The request line.
PROC pin.toggle (VAL INT pin, VAL LEVEL initial.level, CHAN SIGNAL in?)
  CHAN LEVEL v:
  PAR
    toggle (initial.level, in?, v!)
    digital.output (pin, v?)
:
--}}}

--{{{ PROC blink
--* Drives a pin alternately LOW and HIGH on a fixed cycle.
-- Every [@code delay.time] milliseconds, toggles a pin.
-- 
-- @param pin The Arduino pin.
-- @param delay.time The number of milliseconds between toggles.
PROC blink (VAL INT pin, delay.time)
  CHAN SIGNAL s:
  PAR
    tick (delay.time, s!)
    pin.toggle (pin, LOW, s?)
:
--}}}

--{{{ PROC heartbeat
--* A parallel health monitor.
--FIXME: 20100714 drew
--  There are more boards w/o board LEDs... Do we even want this PROC?
-- Blinks the LED.PIN  every 500 ms.
--FIXME: If there is no LED.PIN, I'd like to see a board-specific die(..)
-- 20100710 MCJ
-- Further, death looks like this:
-- Final machine state:
-- file=plumbing.module line=273
-- wptr=0326 (rel=004a)  iptr=d56b (rel=0537)  eflags=0001 sflags=0000
-- areg=d580 breg=0004 creg=0004  oreg=0000
-- 8000 8000 0000 d582 8000 8000 8000 wptr>d580 0320 0004 002b d58b 0002 0000 
-- 64 9c 1f f3 b3 22 f0 22 4b d3 21 f0 iptr>22 f0 60 bd 22 23 f7 d2 42 d1 21 42 
--
-- We may want to improve that... perhaps by using die() in some way. 
PROC heartbeat ()
  IF
    LED.PIN > 0
      blink (LED.PIN, 500)
    TRUE
      die("This board does not have an LED pin. Sorry.")
:
--}}}

--{{{ PROC ADC
--* Reads the analog value of a given pin on a signal request.
-- Currently not parallel safe.
--
-- @param pin The Arduino pin number (A0 - A5)
-- @param ref The source of the reference voltage. Either VCC (internal) or
--   AREF (external).
-- @param req The request line.
-- @param val The current analog reading, 0 - 1023
PROC adc (VAL INT board.pin, VAL BOOL ref, CHAN SIGNAL req?, CHAN INT val!)
  INITIAL INT avr.pin IS board.to.chip(board.pin):
  INT v:
  SEQ
    WHILE TRUE
      SEQ
        req ? SIGNAL
        adc.vcc (avr.pin, v)
        val ! v
:
--}}}

--{{{ PROC clamp.[byte/int]
--* Limits the range of values in a stream.
-- Takes a low and high limit, and any bytes read in that
-- are below the 'low' value are clamped to low, and likewise
-- with the 'high' value. 
--
-- @param low The lower limit for valid numbers.
-- @param high The upper limit for valid numbers.
-- @param in The input stream of BYTEs.
-- @param out The output stream of BYTEs.
PROC clamp.byte (VAL BYTE low, high, CHAN BYTE in?, out!)
  BYTE v:
  WHILE TRUE
    SEQ
      in ? v
      IF
        v < low
          v := low
        v > high
          v := high
        TRUE
          SKIP
      out ! v
:

--* Limits the range of values in a stream.
-- Takes a low and high limit, and any integers read in that
-- are below the 'low' value are clamped to low, and likewise
-- with the 'high' value. 
--
-- @param low The lower limit for valid numbers.
-- @param high The upper limit for valid numbers.
-- @param in The input stream of INTs.
-- @param out The output stream of INTs.
PROC clamp.int (VAL INT low, high, CHAN INT in?, out!)
  INT v:
  WHILE TRUE
    SEQ
      in ? v
      IF
        v < low
          v := low
        v > high
          v := high
        TRUE
          SKIP
      out ! v
:
--}}}

--{{{ PROC crawl.[byte/int]
--FIXME: 20100714 drew These PROCs are just shoddy. Re-write them.

--* Crawls a BYTE from [low] to [high] and back down (and back up, etc.)
-- by [step]. Does not cap pos at low or high, it simply checks for
-- <= or >=.
--
-- @param low The lower limit at which the pos begins moving upward.
-- @param high The upper limit at which the pos begins moving downward.
-- @param step the step pos moves for every send.
-- @param out The output stream of BYTEs.
PROC crawl.byte (VAL BYTE low, high, step, VAL INT wait, CHAN BYTE out!)
  INITIAL BYTE pos IS 0:
  INITIAL BOOL up IS TRUE:
  WHILE TRUE
    SEQ
      IF
        up = TRUE
          IF
            pos < high
              pos := pos + step
            TRUE
              up := FALSE
        TRUE
          IF
            pos > low
              pos := pos - step
            TRUE
              up := TRUE
      out ! pos
      delay (wait)
:

--* Crawls a INT from [low] to [high] and back down (and back up, etc.)
-- by [step]. Does not cap pos at low or high, it simply checks for
-- <= or >=.
--
-- @param low The lower limit at which the pos begins moving upward.
-- @param high The upper limit at which the pos begins moving downward.
-- @param step the step pos moves for every send.
-- @param out The output stream of INTs.
PROC crawl.int (VAL INT low, high, step, VAL INT wait,  CHAN INT out!)
  INITIAL INT pos IS 0:
  INITIAL BOOL up IS TRUE:
  WHILE TRUE
    SEQ
      IF
        up = TRUE
          IF
            pos < high
              pos := pos + step
            TRUE
              up := FALSE
        TRUE
          IF
            pos > low
              pos := pos - step
            TRUE
              up := TRUE
      out ! pos
      delay (wait)
:
--}}}

--{{{ PROC pwm[8/16]
--FIXME: 20100714 drew These PROC are also crufty.
-- The while PWM architecture should be re-written as a PROTOCOL.

--* Writes an analog value to a pin.
-- For a given (PWM) pin, sets the observed analog level to a value between
-- 0 and 255. Negative values are treated as 0, and values greater
-- than 255 are treated as 255.
--
-- @param pin The Arduino pin number.
-- @param level The input level channel.
PROC pwm8 (VAL INT board.pin, CHAN BYTE level?)
  INITIAL BYTE lvl IS 0:
  INITIAL INT avr.pin IS board.to.chip (board.pin):
  CHAN BYTE clamped:
  SEQ
    -- WARNING: 20100712
    -- Debugging the odd compiler/CASE problem in pwmarch.module.
    -- Left the debug for now in case we find more problems.
    --serial.write.string("Setting digital mode*n")
    --serial.write.string("Board: ")
    --serial.write.int(board.pin)
    --serial.write.string("*n")
    --serial.write.string("AVR: ")
    --serial.write.int(avr.pin)
    --serial.write.string("*n")
    digital.mode (board.pin, OUTPUT)
    --serial.write.string("pwm8.setup*n")
    pwm8.setup (avr.pin, 64)
    PAR
      clamp (0, 255, level?, clamped!)
      WHILE TRUE
        SEQ
          clamped ? lvl
          --serial.write.string("set.compare*n")
          pwm8.set.compare (avr.pin, lvl)
          --serial.write.string("after compare*n")
:

--* Writes an analog value to a pin.
-- For a given (analog) pin, sets the level to a value between
-- 0 and TOP. Negative values are treated as 0, and values greater
-- than TOP are treated as TOP.
--
-- @param pin The Arduino pin number
-- @param top The highest level top can be set to.
-- @param level The input level channel.
PROC pwm16 (VAL INT board.pin, VAL INT top, CHAN INT level?)
  INITIAL INT lvl IS 0:
  INITIAL INT avr.pin IS board.to.chip (board.pin):
  CHAN INT clamped:
  SEQ
    -- WARNING 20100712
    -- Debugging the odd compiler/CASE problem in pwmarch.module.
    -- Left the debug for now in case we find more problems.
    --serial.write.string("Setting digital mode*n")
    --serial.write.string("Board: ")
    --serial.write.int(board.pin)
    --serial.write.string("*n")
    --serial.write.string("AVR: ")
    --serial.write.int(avr.pin)
    --serial.write.string("*n")
    digital.mode (board.pin, OUTPUT)
    --serial.write.string("pwm8.setup*n")
    pwm16.setup (avr.pin, 8)
    pwm16.set.top (avr.pin, top)
    PAR
      clamp.int (0, top, level?, clamped!)
      WHILE TRUE
        SEQ
          clamped ? lvl
          --serial.write.string("set.compare*n")
          pwm16.set.compare (avr.pin, lvl)
          --serial.write.string("after compare*n")
:
--}}}


--{{{ DEPRECATED CRAP
#IF FALSE
-- While this is a nice interrupt-driven approach to ADC,
-- it is not parallel-safe. Because we deschedule when doing a reading,
-- someone else can come in and start another. I have replaced this 
-- with a busywait version until I can come up with a better solution.
--
-- The busywait obviously blocks our runtime until a reading finishes.
-- However, it eliminates the critical section.
PROC adc (VAL INT pin, CHAN SIGNAL req?, CHAN INT val!)
  PLACED [MAX.PORT]BYTE ports 0:
  INT16 result:   
  SEQ
    -- Reference voltage is Vcc; select channel
    ports[ADMUX] := (1 << REFS0) \/ (BYTE pin)
    -- Enable ADC; enable interrupt; clock prescale 128
    ports[ADCSRA] := (BV (ADEN) \/ BV (ADIE)) \/ (7 << ADPS0)
    -- Disable digital inputs on all six ADC pins
    ports[DIDR0] := #3F
    WHILE TRUE
      SEQ
        req ? SIGNAL
        -- Start conversion
        ports[ADCSRA] := ports[ADCSRA] \/ BV (ADSC)

        -- serialWrite("Waiting for conversion...")
        -- Wait for conversion to complete
        INT t:
        wait.for.interrupt (VINTR.ADC, t)

        -- Read value
        -- (We can't do this by retyping ports, since that does a 16-bit read)
        [2]BYTE bytes RETYPES result:
        bytes[0], bytes[1] := ports[ADCL], ports[ADCH]

        val ! (INT result)
:


-- This version of digital.input is so much specific to the arduino.
-- I think the version above is better, but it mgiht not be tested yet..
--* Read digital levels on pin 2 or 3.
-- For only pin 2 or pin 3 on the Arduino, this procedure
-- will output a LEVEL (either LOW or HIGH) whenever the
-- pin changes value.
--
-- @param pin The Arduino pin number (2 or 3 only)
-- @param out The LEVEL, output when the pin changes level.
PROC digital.input (VAL INT pin, CHAN LEVEL out!)
  PLACED [MAX.PORT]BYTE ports 0:
  #PRAGMA DEFINED ports
  INT wl:
  INITIAL INT vintr IS (-1):
  LEVEL level, last.level:
  PROC read ()
    SEQ
      digital.read (pin, wl)
      level := LEVEL wl
  :
  SEQ
    CASE pin
      2
        SEQ
          vintr := VINTR.INT0
          ports[EICRA] := (ports[EICRA] /\ (~(3 << ISC00))) \/ (1 << ISC00)
          ports[EIMSK] := ports[EIMSK] \/ (BV (INT0))
      3
        SEQ
          vintr := VINTR.INT1
          ports[EICRA] := (ports[EICRA] /\ (~(3 << ISC10))) \/ (1 << ISC10)
          ports[EIMSK] := ports[EIMSK] \/ (BV (INT1))
      ELSE
        die ("pin does not support interrupts")
    read ()
    last.level := level
    WHILE TRUE
      SEQ
        IF
          level <> last.level
            out ! level
          TRUE
            SKIP
        INT any:
        wait.for.interrupt (vintr, any)
        read ()
:

--* Watches for button presses on pin 2 or 3.
-- When a button is pressed (must be attached to pin 2 or 3)
-- a SIGNAL is generated. Uses digital.input, debounce, and 
-- level.to.signal.
--
-- @param pin The pin the button is connected to (must be 2 or 3)
-- @param out SIGNALs generated when the button is pressed.
PROC button.press (VAL INT pin, CHAN SIGNAL out!)
  CHAN LEVEL a, b:
  PAR
    digital.input (pin, a!)
    debounce (a?, b!)
    level.to.signal (b?, out!)
:

#ENDIF
--}}}


#ENDIF
