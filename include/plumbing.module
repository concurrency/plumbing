--** The Plumbing library.
--
-- [@code PROC]s in this module generally have arguments in this order:
--
-- [@item] non-channels;
-- [@item] input channels;
-- [@item] output channels.
--
-- @module plumbing

#IF NOT (DEFINED (PLUMBING.MODULE))
#DEFINE PLUMBING.MODULE

#INCLUDE "avr.module"
#INCLUDE "boardmap.module"
#INCLUDE "printing.module"

DATA TYPE LEVEL IS INT:
VAL LEVEL LOW IS #0:
VAL LEVEL HIGH IS #1:

--{{{  constants
--* Symbolic constant for digital LOW on an Arduino pin.
-- VAL INT LOW IS #0:
--* Symbolic constant for digital HIGH on an Arduino pin.
-- VAL INT HIGH IS #1:

VAL INT INPUT IS #0:
VAL INT OUTPUT IS #1:
--}}}

-- FIXME 20100706 MCJ
-- I think the USART.MODULE now has a lot of this functionality.
-- I'm commenting this out until I double-check and bring in 
-- the appropriate high-level interface.

PROC serial.write (CHAN BYTE in?)
  WHILE TRUE
    BYTE b:
    SEQ
      in ? b
      serial.write.byte (0, b)
:

--{{{  PROC serialWriteString
--* Write a string to the serial port.
--
-- @param port Serial port to write to.
-- @param string Bytes to write.
PROC serial.write.string (VAL []BYTE string)
  SEQ i = 0 FOR SIZE string
    serial.write.byte (0, string[i])
:
--}}}

PROC serial.read (CHAN BYTE out!)
  WHILE TRUE
    BYTE b:
    SEQ
      serial.read.byte (0, b)
      out ! b
:


PROC serial.tx (VAL INT port, CHAN BYTE in?)
  WHILE TRUE
    BYTE b:
    SEQ
      in ? b
      serial.write.byte (port, b)
:

PROC serial.rx (VAL INT port, CHAN BYTE out!)
  WHILE TRUE
    BYTE b:
    SEQ
      serial.read.byte (port, b)
      out ! b
:

--{{{  PROC serial.rx.int
--* Write an [@code INT] to the serial port in hex.
--
-- @param port The serial port to write to.
-- @param n The integer to write.
PROC serial.tx.int (VAL INT port, CHAN INT n?)
  VAL []BYTE digits IS "0123456789abcdef":
  INT num:
  WHILE TRUE
    SEQ
      n ? num
      SEQ i = 3 FOR 4 STEP -1
        serial.write.byte (port, digits[(num >> (i * 4)) /\ #F])
      serial.write.byte (port, '*n')
:
--}}}

--FIXME: The int/int32 helper methods don't use any chanels or signals. Methinks this should change.
--{{{  PROC serial.write.int
--* Write an [@code INT] to the serial port in hex.
--
-- @param n The integer to write.
PROC serial.write.int (VAL INT n)
  VAL []BYTE digits IS "0123456789abcdef":
  SEQ i = 3 FOR 4 STEP -1
    serial.write.byte (0, digits[(n >> (i * 4)) /\ #F])
:
--}}}

--{{{  PROC serial.write.int32
--* Write an [@code INT32] to the serial port in hex.
--
-- @param n The long integer ([@code INT32]) to write.
PROC serial.write.int32 (VAL INT32 n)
  VAL []BYTE digits IS "0123456789abcdef":
  SEQ i = 7 FOR 8 STEP -1
    serial.write.byte (0, digits[INT ((n >> (i * 4)) /\ #F)])
:
--}}}


--{{{  PROC serial.tx.int32
--* Write an [@code INT32] to the serial port in hex.
--
-- @oaram port The serial port to write to.
-- @param n The long integer ([@code INT32]) to write.
PROC serial.tx.int32 (VAL INT port, VAL INT32 n)
  VAL []BYTE digits IS "0123456789abcdef":
  SEQ i = 7 FOR 8 STEP -1
    serial.write.byte (port, digits[INT ((n >> (i * 4)) /\ #F)])
:
--}}}
--{{{  PROC digital.write
PROC digital.write (VAL INT board.pin, state)
  INITIAL INT avr.pin IS board.to.chip(board.pin):
  INT r.ddr, r.port, r.pin, bit:
  SEQ
    -- Need to do ... chip.to.gpio...
    r.ddr, r.port, r.pin, bit := chip.to.gpio (avr.pin)
    pin.write(r.port, bit, state)
:
--}}}

--{{{  PROC digital.read
PROC digital.read (VAL INT board.pin, RESULT INT state)
  INITIAL INT avr.pin IS board.to.chip(board.pin):
  INT r.ddr, r.port, r.pin, bit:
  SEQ
    r.ddr, r.port, r.pin, bit := chip.to.gpio (avr.pin)
    pin.read(r.pin, bit, state)
:
--}}}

--{{{  PROC digital.mode
PROC digital.mode (VAL INT board.pin, mode)
  INITIAL INT avr.pin IS board.to.chip(board.pin):
  INT r.ddr, r.port, r.pin, bit:
  SEQ
    r.ddr, r.port, r.pin, bit := chip.to.gpio (avr.pin)
    pin.mode(r.ddr, bit, mode)
:
--}}}


--* Set digital levels on a pin.
-- Reads LEVEL values (LOW or HIGH) on the input 
-- channel, and sets the value of the specified pin 
-- accordingly.
--
-- @param pin The Arduino pin number
-- @param in Pin levels (LOW or HIGH)
PROC digital.output (VAL INT board.pin, CHAN LEVEL in?)
  LEVEL v:
  SEQ
    in ? v
    digital.mode (board.pin, OUTPUT)
    WHILE TRUE
      SEQ
        digital.write (board.pin, INT v)
        in ? v
:

--FIXME: digital.input is so much specific to the arduino, which needs to change.
--* Read digital levels on pin 2 or 3.
-- For only pin 2 or pin 3 on the Arduino, this procedure
-- will output a LEVEL (either LOW or HIGH) whenever the
-- pin changes value.
--
-- @param pin The Arduino pin number (2 or 3 only)
-- @param out The LEVEL, output when the pin changes level.
PROC digital.input (VAL INT pin, CHAN LEVEL out!)
  PLACED [MAX.PORT]BYTE ports 0:
  #PRAGMA DEFINED ports
  INT wl:
  INITIAL INT vintr IS (-1):
  LEVEL level, last.level:
  PROC read ()
    SEQ
      digital.read (pin, wl)
      level := LEVEL wl
  :
  SEQ
    CASE pin
      2
        SEQ
          vintr := VINTR.INT0
          ports[EICRA] := (ports[EICRA] /\ (~(3 << ISC00))) \/ (1 << ISC00)
          ports[EIMSK] := ports[EIMSK] \/ (BV (INT0))
      3
        SEQ
          vintr := VINTR.INT1
          ports[EICRA] := (ports[EICRA] /\ (~(3 << ISC10))) \/ (1 << ISC10)
          ports[EIMSK] := ports[EIMSK] \/ (BV (INT1))
      ELSE
        die ("pin does not support interrupts")
    read ()
    last.level := level
    WHILE TRUE
      SEQ
        IF
          level <> last.level
            out ! level
          TRUE
            SKIP
        INT any:
        wait.for.interrupt (vintr, any)
        read ()
:


VAL INT DEBOUNCE.TIME IS 50:

--* Debounce a channel.
-- Debounces a channel of LEVELs. Specifically, if 
-- multiple values come in within the DEBOUNCE.TIME 
-- (currently 50ms), only the first value is passed through.
--
-- @param in The incoming LEVEL values
-- @param out The outgoing LEVEL values, debounced
PROC debounce (CHAN LEVEL in?, out!)
  LEVEL v:
  WHILE TRUE
    TIMER tim:
    INT t:
    SEQ
      in ? v
      tim ? t
      t := t PLUS DEBOUNCE.TIME
      INITIAL BOOL ignoring IS TRUE:
      WHILE ignoring
        ALT
          LEVEL any:
          in ? any
            SKIP
          tim ? AFTER t
            ignoring := FALSE
      out ! v
:

--* Convert a LEVEL to a SIGNAL.
-- Consumes a stream of LEVEL values, and emits a SIGNAL
-- for each LEVEL received, regardless of whether it is
-- LOW or HIGH.
--
-- @param in Input LEVEL values.
-- @param out Output SIGNALs.
PROC level.to.signal (CHAN LEVEL in?, CHAN SIGNAL out!)
  WHILE TRUE
    SEQ
      LEVEL any:
      in ? any
      out ! SIGNAL
:

--* Invert LEVELs.
-- Reads in LEVEL values, and outputs the opposite.
-- Upon receiving a LOW, sends a HIGH, and visa versa.
--
-- @param in Incoming LEVEL values.
-- @param out Outgoing LEVEL values, inverted.
PROC invert.level (CHAN LEVEL in?, out!)
  WHILE TRUE
    LEVEL v:
    SEQ
      in ? v
      IF
        v = HIGH
          out ! LOW
        TRUE -- If v = LOW
          out ! HIGH
:

--* Watches for button presses on pin 2 or 3.
-- When a button is pressed (must be attached to pin 2 or 3)
-- a SIGNAL is generated. Uses digital.input, debounce, and 
-- level.to.signal.
--
-- @param pin The pin the button is connected to (must be 2 or 3)
-- @param out SIGNALs generated when the button is pressed.
PROC button.press (VAL INT pin, CHAN SIGNAL out!)
  CHAN LEVEL a, b:
  PAR
    digital.input (pin, a!)
    debounce (a?, b!)
    level.to.signal (b?, out!)
:

--* Generates a consistent stream of SIGNALs.
-- Every [@code period] milliseconds, a SIGNAL is generated.
--
-- @param period A delay time in milliseconds.
-- @param out SIGNALs generated after the given delay.
PROC tick (VAL INT period, CHAN SIGNAL out!)
  WHILE TRUE
    SEQ
      delay (period)
      out ! SIGNAL
:

--* Outputs an alternating stream of LEVEL values.
-- Starting with an initial level (either LOW or HIGH), this 
-- process outputs a stream of alternating LEVEL values upon 
-- request. On receiving a SIGNAL, the next LEVEL is emitted
--
-- @param initial.level Either LOW or HIGH to start.
-- @param in The request line.
-- @param out The alternating stream of LEVEL values.
PROC toggle (VAL LEVEL initial.level, CHAN SIGNAL in?, CHAN LEVEL out!)
  INITIAL LEVEL level IS initial.level:
  WHILE TRUE
    SEQ
      out ! level
      in ? SIGNAL
      IF
        level = HIGH
          level := LOW
        TRUE -- If level = LOW
          level := HIGH
:

--* Drives a pin alternately LOW and HIGH.
-- Upon request, alternates the level of a pin from LOW to HIGH.
-- 
-- @param pin The (digital) Arduino pin we want to drive.
-- @param initial.level Either LOW or HIGH.
-- @param in The request line.
PROC pin.toggle (VAL INT pin, VAL LEVEL initial.level, CHAN SIGNAL in?)
  CHAN LEVEL v:
  PAR
    toggle (initial.level, in?, v!)
    digital.output (pin, v?)
:

--* Drives a pin alternately LOW and HIGH on a fixed cycle.
-- Every [@code delay.time] milliseconds, toggles a pin.
-- 
-- @param pin The Arduino pin.
-- @param delay.time The number of milliseconds between toggles.
PROC blink (VAL INT pin, delay.time)
  CHAN SIGNAL s:
  PAR
    tick (delay.time, s!)
    pin.toggle (pin, LOW, s?)
:

--* A parallel health monitor.
-- Blinks the LED.PIN  every 500 ms.
--FIXME: If there is no LED.PIN, I'd like to see a board-specific die(..)
-- 20100710 MCJ
-- Further, death looks like this:
-- Final machine state:
-- file=plumbing.module line=273
-- wptr=0326 (rel=004a)  iptr=d56b (rel=0537)  eflags=0001 sflags=0000
-- areg=d580 breg=0004 creg=0004  oreg=0000
-- 8000 8000 0000 d582 8000 8000 8000 wptr>d580 0320 0004 002b d58b 0002 0000 
-- 64 9c 1f f3 b3 22 f0 22 4b d3 21 f0 iptr>22 f0 60 bd 22 23 f7 d2 42 d1 21 42 
--
-- We may want to improve that... perhaps by using die() in some way. 
PROC heartbeat ()
  IF
    LED.PIN > 0
      blink (LED.PIN, 500)
    TRUE
      die("This board does not have an LED pin. Sorry.")
:

--* Read an analog value.
-- For the given pin, will do an analog read of that pin
-- and emit the value upon request. Currently not parallel safe.
--
-- @param pin The Arduino pin number (A0 - A5)
-- @param req The request line.
-- @param val The current analog reading, 0 - 1023
PROC adc (VAL INT board.pin, CHAN SIGNAL req?, CHAN INT val!)
  INT v:
  INITIAL INT avr.pin IS board.to.chip (board.pin):
  SEQ
    WHILE TRUE
      SEQ
        req ? SIGNAL
        adc.vcc (avr.pin, v)
        val ! v
:

#IF TRUE 
-- FIXME 20100706 MCJ
-- These are PROCs that now need to be rewritten or removed. They no 
-- longer work/fit within the lower-level framework we've built on top of plumbing.

--* Limits the range of values in a stream.
-- Takes a low and high limit, and any integers read in that
-- are below the 'low' value are clamped to low, and likewise
-- with the 'high' value. 
--
-- @param low The lower limit for valid numbers.
-- @param high The upper limit for valid numbers.
-- @param in The input stream of INTs.
-- @param out The output stream of INTs.
PROC clamp (VAL BYTE low, high, CHAN BYTE in?, out!)
  BYTE v:
  WHILE TRUE
    SEQ
      in ? v
      IF
        v < low
          v := low
        v > high
          v := high
        TRUE
          SKIP
      out ! v
:

--* Writes an analog value to a pin.
-- For a given (analog) pin, sets the level to a value between
-- 0 and 255. Negative values are treated as 0, and values greater
-- than 255 are treated as 255.
--
-- @param pin The Arduino pin number
-- @param level The input level.
PROC pwm8 (VAL INT pin, CHAN BYTE level?)
  INITIAL BYTE lvl IS 0:
  INITIAL INT avr.pin IS board.to.chip (pin):
  SEQ
    digital.mode (pin, OUTPUT)
    pwm8.setup (avr.pin, 64)
    CHAN BYTE clamped:
    PAR
      clamp (0, 255, level?, clamped!)
      WHILE TRUE
        SEQ
          clamped ? lvl
          pwm8.set.compare (avr.pin, lvl)
:
#ENDIF

#IF FALSE
-- While this is a nice interrupt-driven approach to ADC,
-- it is not parallel-safe. Because we deschedule when doing a reading,
-- someone else can come in and start another. I have replaced this 
-- with a busywait version until I can come up with a better solution.
--
-- The busywait obviously blocks our runtime until a reading finishes.
-- However, it eliminates the critical section.
PROC adc (VAL INT pin, CHAN SIGNAL req?, CHAN INT val!)
  PLACED [MAX.PORT]BYTE ports 0:
  INT16 result:   
  SEQ
    -- Reference voltage is Vcc; select channel
    ports[ADMUX] := (1 << REFS0) \/ (BYTE pin)
    -- Enable ADC; enable interrupt; clock prescale 128
    ports[ADCSRA] := (BV (ADEN) \/ BV (ADIE)) \/ (7 << ADPS0)
    -- Disable digital inputs on all six ADC pins
    ports[DIDR0] := #3F
    WHILE TRUE
      SEQ
        req ? SIGNAL
        -- Start conversion
        ports[ADCSRA] := ports[ADCSRA] \/ BV (ADSC)

        -- serialWrite("Waiting for conversion...")
        -- Wait for conversion to complete
        INT t:
        wait.for.interrupt (VINTR.ADC, t)

        -- Read value
        -- (We can't do this by retyping ports, since that does a 16-bit read)
        [2]BYTE bytes RETYPES result:
        bytes[0], bytes[1] := ports[ADCL], ports[ADCH]

        val ! (INT result)
:
#ENDIF


#ENDIF
