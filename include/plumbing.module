--
--	Copyright (C) 1997-2010   Christian Jacobsen
--                                Matt Jadud
--                                Michael Andrew Pirrone-Brusse
--                                Adam Sampson
--
--	This library is free software; you can redistribute it and/or
--	modify it under the terms of the GNU Lesser General Public
--	License as published by the Free Software Foundation; either
--	version 2 of the License, or (at your option) any later version.
--
--	This library is distributed in the hope that it will be useful,
--	but WITHOUT ANY WARRANTY; without even the implied warranty of
--	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
--	Lesser General Public License for more details.
--
--	You should have received a copy of the GNU Lesser General Public
--	License along with this library; if not, write to the Free Software
--	Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307  USA
--
--** The Plumbing library.
--
-- [@code PROC]s in this module generally have arguments in this order:
--
-- [@item] non-channels;
-- [@item] input channels;
-- [@item] output channels.
--
-- @module plumbing

#IF NOT (DEFINED (PLUMBING.MODULE))
#DEFINE PLUMBING.MODULE

#INCLUDE "avr.module"
#INCLUDE "boardmap.module"
#INCLUDE "digital.module"
#INCLUDE "printing.module"
#INCLUDE "servo.module"

--{{{ Constants
-- LEVEL, INPUT and OUTPUT are now defined in digital.module
-- DATA TYPE LEVEL IS INT:
-- VAL LEVEL LOW IS #0:
-- VAL LEVEL HIGH IS #1:

--VAL INT INPUT IS #0:
--VAL INT OUTPUT IS #1:

VAL BOOL VCC IS TRUE:
VAL BOOL AREF IS FALSE:

VAL INT DEBOUNCE.TIME IS 50:
--}}}


--{{{ PROC debounce
--* Debounce a channel.
-- Debounces a channel of LEVELs. Specifically, if 
-- multiple values come in within the DEBOUNCE.TIME 
-- (currently 50ms), only the first value is passed through.
--
-- @param in The incoming LEVEL values
-- @param out The outgoing LEVEL values, debounced
PROC debounce (CHAN LEVEL in?, out!)
  LEVEL v:
  WHILE TRUE
    TIMER tim:
    INT t:
    SEQ
      in ? v
      tim ? t
      t := t PLUS DEBOUNCE.TIME
      INITIAL BOOL ignoring IS TRUE:
      WHILE ignoring
        ALT
          LEVEL any:
          in ? any
            SKIP
          tim ? AFTER t
            ignoring := FALSE
      out ! v
:
--}}}

--{{{ PROC level.to.signal
--* Convert a LEVEL to a SIGNAL.
-- Consumes a stream of LEVEL values, and emits a SIGNAL
-- for each LEVEL received, regardless of whether it is
-- LOW or HIGH.
--
-- @param in Input LEVEL values.
-- @param out Output SIGNALs.
PROC level.to.signal (CHAN LEVEL in?, CHAN SIGNAL out!)
  WHILE TRUE
    SEQ
      LEVEL any:
      in ? any
      out ! SIGNAL
:
--}}}

--{{{ PROC invert.level
--* Invert LEVELs.
-- Reads in LEVEL values, and outputs the opposite.
-- Upon receiving a LOW, sends a HIGH, and visa versa.
--
-- @param in Incoming LEVEL values.
-- @param out Outgoing LEVEL values, inverted.
PROC invert.level (CHAN LEVEL in?, out!)
  WHILE TRUE
    LEVEL v:
    SEQ
      in ? v
      IF
        v = HIGH
          out ! LOW
        TRUE -- If v = LOW
          out ! HIGH
:
--}}}

--{{{ PROC tick
--* Generates a consistent stream of SIGNALs.
-- Every [@code period] milliseconds, a SIGNAL is generated.
--
-- @param period A delay time in milliseconds.
-- @param out SIGNALs generated after the given delay.
PROC tick (VAL INT period, CHAN SIGNAL out!)
  WHILE TRUE
    SEQ
      delay (period)
      out ! SIGNAL
:
--}}}

--{{{ PROC toggle
--* Outputs an alternating stream of LEVEL values.
-- Starting with an initial level (either LOW or HIGH), this 
-- process outputs a stream of alternating LEVEL values upon 
-- request. On receiving a SIGNAL, the next LEVEL is emitted
--
-- @param initial.level Either LOW or HIGH to start.
-- @param in The request line.
-- @param out The alternating stream of LEVEL values.
PROC toggle (VAL LEVEL initial.level, CHAN SIGNAL in?, CHAN LEVEL out!)
  INITIAL LEVEL level IS initial.level:
  WHILE TRUE
    SEQ
      out ! level
      in ? SIGNAL
      IF
        level = HIGH
          level := LOW
        TRUE -- If level = LOW
          level := HIGH
:
--}}}

--{{{ PROC pin.toggle
--* Drives a pin alternately LOW and HIGH.
-- Upon request, alternates the level of a pin from LOW to HIGH.
-- 
-- @param pin The (digital) Arduino pin we want to drive.
-- @param initial.level Either LOW or HIGH.
-- @param in The request line.
PROC pin.toggle (VAL INT pin, VAL LEVEL initial.level, CHAN SIGNAL in?)
  CHAN LEVEL v:
  PAR
    toggle (initial.level, in?, v!)
    digital.output (pin, v?)
:
--}}}

--{{{ PROC blink
--* Drives a pin alternately LOW and HIGH on a fixed cycle.
-- Every [@code delay.time] milliseconds, toggles a pin.
-- 
-- @param pin The Arduino pin.
-- @param delay.time The number of milliseconds between toggles.
PROC blink (VAL INT pin, delay.time)
  CHAN SIGNAL s:
  PAR
    tick (delay.time, s!)
    pin.toggle (pin, LOW, s?)
:
--}}}

--{{{ PROC heartbeat
--* A parallel health monitor.
--FIXME: 20100714 drew
--  There are more boards w/o board LEDs... Do we even want this PROC?
-- Blinks the LED.PIN  every 500 ms.
--FIXME: If there is no LED.PIN, I'd like to see a board-specific die(..)
-- 20100710 MCJ
-- Further, death looks like this:
-- Final machine state:
-- file=plumbing.module line=273
-- wptr=0326 (rel=004a)  iptr=d56b (rel=0537)  eflags=0001 sflags=0000
-- areg=d580 breg=0004 creg=0004  oreg=0000
-- 8000 8000 0000 d582 8000 8000 8000 wptr>d580 0320 0004 002b d58b 0002 0000 
-- 64 9c 1f f3 b3 22 f0 22 4b d3 21 f0 iptr>22 f0 60 bd 22 23 f7 d2 42 d1 21 42 
--
-- We may want to improve that... perhaps by using die() in some way. 
PROC heartbeat ()
  IF
    LED.PIN > 0
      blink (LED.PIN, 500)
    TRUE
      die("This board does not have an LED pin. Sorry.")
:
--}}}

--{{{ PROC ADC
--* Reads the analog value of a given pin on a signal request.
-- Currently not parallel safe.
--
-- @param analog.pin The Arduino pin number (A0 - A5)
-- @param ref The source of the reference voltage. Either VCC (internal) or
--   AREF (external).
-- @param req The request line.
-- @param val The current analog reading, 0 - 1023
PROC adc (VAL INT analog.pin, VAL BOOL ref, CHAN SIGNAL req?, CHAN INT val!)
  INITIAL INT avr.pin IS board.analog.to.chip(analog.pin):
  INT v:
  SEQ
    WHILE TRUE
      SEQ
        req ? SIGNAL
        adc.base (avr.pin, ref, v)
        val ! v
:
--}}}

--{{{ PROC mapped.adc
--* Maps the incoming values from a potentiometer (knob, slider, etc.)
-- connected to analog.pin to apropriate values between min and max.
-- @param analog.pin The analog pin the potentiometer is connected to.
-- @param min, max The minimum and maximum values that will be output.
-- @oaram ping In signal that activated a new reading and mapping.
-- @param out The output chanel mapped values are sent out on.
PROC potentiometer (VAL INT analog.pin, min, max, CHAN SIGNAL ping?, CHAN INT out!)
  INITIAL INT avr.pin IS board.analog.to.chip (analog.pin):
  INITIAL INT range IS max - min:
  INT v:

  WHILE TRUE
    SEQ
      ping ? SIGNAL
      adc.base (avr.pin, VCC, v)
      v := ((v  / 1023) * range) + min
      out ! v
:
--}}}
 
--{{{ PROC clamp.[byte/int]
--* Limits the range of values in a stream.
-- Takes a low and high limit, and any bytes read in that
-- are below the 'low' value are clamped to low, and likewise
-- with the 'high' value. 
--
-- @param low The lower limit for valid numbers.
-- @param high The upper limit for valid numbers.
-- @param in The input stream of BYTEs.
-- @param out The output stream of BYTEs.
PROC clamp.byte (VAL BYTE low, high, CHAN BYTE in?, out!)
  BYTE v:
  WHILE TRUE
    SEQ
      in ? v
      IF
        v < low
          v := low
        v > high
          v := high
        TRUE
          SKIP
      out ! v
:

--* Limits the range of values in a stream.
-- Takes a low and high limit, and any integers read in that
-- are below the 'low' value are clamped to low, and likewise
-- with the 'high' value. 
--
-- @param low The lower limit for valid numbers.
-- @param high The upper limit for valid numbers.
-- @param in The input stream of INTs.
-- @param out The output stream of INTs.
PROC clamp.int (VAL INT low, high, CHAN INT in?, out!)
  INT v:
  WHILE TRUE
    SEQ
      in ? v
      IF
        v < low
          v := low
        v > high
          v := high
        TRUE
          SKIP
      out ! v
:
--}}}

--{{{ PROC crawl.[byte/int]
--FIXME: 20100714 drew These PROCs are just shoddy. Re-write them.

--* Crawls a BYTE from [low] to [high] and back down (and back up, etc.)
-- by [step]. Does not cap pos at low or high, it simply checks for
-- <= or >=.
--
-- @param high The upper limit at which the pos begins moving downward.
-- @param step The step pos moves for every send.
-- @param wait The time -- in miliseconds -- to wait after a successful send
--   before attempting another.
-- @param out The output stream of BYTEs.
PROC crawl.byte (VAL BYTE high, step, VAL INT wait, CHAN BYTE out!)
  INITIAL BYTE pos IS 0:
  INITIAL BOOL up IS TRUE:

  WHILE TRUE
    SEQ
      IF
        up = TRUE
          SEQ
            pos := pos + step
            IF
              pos < high
                SKIP
              pos > high
                SEQ
                  pos := high
                  up := FALSE
              TRUE
                up := FALSE
        TRUE
          SEQ
            pos := pos - step
            IF
              pos > 0
                SKIP
              pos < 0
                SEQ
                  pos := 0
                  up := TRUE
              TRUE
                up := TRUE
      out ! pos
      delay (wait)
:

--* Crawls a INT from [low] to [high] and back down (and back up, etc.)
-- by [step]. Does not cap pos at low or high, it simply checks for
-- <= or >=.
--
-- @param high The upper limit at which the pos begins moving downward.
-- @param step the step pos moves for every send.
-- @param wait The time -- in miliseconds -- to wait after a successful send
--   before attempting another.
-- @param out The output stream of INTs.
PROC crawl.int (VAL INT high, step, VAL INT wait,  CHAN INT out!)
  INITIAL INT pos IS 0:
  INITIAL BOOL up IS TRUE:
  
  WHILE TRUE
    SEQ
      IF
        up = TRUE
          SEQ
            pos := pos + step
            IF
              pos < high
                SKIP
              pos > high
                SEQ
                  pos := high
                  up := FALSE
              TRUE
                up := FALSE
        TRUE
          SEQ
            pos := pos - step
            IF
              pos > 0
                SKIP
              pos < 0
                SEQ
                  pos := 0
                  up := TRUE
              TRUE
                up := TRUE
      out ! pos
      delay (wait)
:
--}}}

--{{{ PROC pwm[8/16]
--FIXME: 20100714 drew These PROC are also crufty.
-- The whole PWM architecture should be re-written as a PROTOCOL.

--* Writes an analog value to a pin.
-- For a given (PWM) pin, sets the observed analog level to a value between
-- 0 and 255. Negative values are treated as 0, and values greater
-- than 255 are treated as 255.
--
-- @param board.pin The Arduino pin number.
-- @param level The input level channel.
PROC pwm8 (VAL INT board.pin, CHAN BYTE level?)
  INITIAL BYTE lvl IS 0:
  INITIAL INT avr.pin IS board.to.chip (board.pin):
  CHAN BYTE clamped:
  SEQ
    -- WARNING: 20100712
    -- Debugging the odd compiler/CASE problem in pwmarch.module.
    -- Left the debug for now in case we find more problems.
    --serial.write.string("Setting digital mode*n")
    --serial.write.string("Board: ")
    --serial.write.int(board.pin)
    --serial.write.string("*n")
    --serial.write.string("AVR: ")
    --serial.write.int(avr.pin)
    --serial.write.string("*n")
    digital.mode (board.pin, OUTPUT)
    --serial.write.string("pwm8.setup*n")
    pwm8.setup (avr.pin, 64)
    PAR
      clamp.byte (0, 255, level?, clamped!)
      WHILE TRUE
        SEQ
          clamped ? lvl
          --serial.write.string("set.compare*n")
          pwm8.set.compare (avr.pin, lvl)
          --serial.write.string("after compare*n")
:

--* Writes an analog value to a pin.
-- For a given (analog) pin, sets the level to a value between
-- 0 and TOP. Negative values are treated as 0, and values greater
-- than TOP are treated as TOP.
--
-- @param board.pin The Arduino pin number
-- @param top The highest level top can be set to.
-- @param level The input level channel.
PROC pwm16 (VAL INT board.pin, VAL INT top, CHAN INT level?)
  INITIAL INT lvl IS 0:
  INITIAL INT avr.pin IS board.to.chip (board.pin):
  CHAN INT clamped:
  SEQ
    -- WARNING 20100712
    -- Debugging the odd compiler/CASE problem in pwmarch.module.
    -- Left the debug for now in case we find more problems.
    --serial.write.string("Setting digital mode*n")
    --serial.write.string("Board: ")
    --serial.write.int(board.pin)
    --serial.write.string("*n")
    --serial.write.string("AVR: ")
    --serial.write.int(avr.pin)
    --serial.write.string("*n")
    digital.mode (board.pin, OUTPUT)
    --serial.write.string("pwm8.setup*n")
    pwm16.setup (avr.pin, 8)
    pwm16.set.top (avr.pin, top)
    PAR
      clamp.int (0, top, level?, clamped!)
      WHILE TRUE
        SEQ
          clamped ? lvl
          --serial.write.string("set.compare*n")
          pwm16.set.compare (avr.pin, lvl)
          --serial.write.string("after compare*n")
:
--}}}

#ENDIF
