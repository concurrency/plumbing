--
--	Copyright (C) 2009-2010   Christian Jacobsen
--      Copyright (C) 2009-2010   Matt Jadud
--      Copyright (C)      2010   Michael Andrew Pirrone-Brusse
--      Copyright (C) 2009-2010   Adam Sampson
--
--	This library is free software; you can redistribute it and/or
--	modify it under the terms of the GNU Lesser General Public
--	License as published by the Free Software Foundation; either
--	version 2 of the License, or (at your option) any later version.
--
--	This library is distributed in the hope that it will be useful,
--	but WITHOUT ANY WARRANTY; without even the implied warranty of
--	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
--	Lesser General Public License for more details.
--
--      You should have received a copy of the GNU General Public License
--      along with this program.  If not, see <http://www.gnu.org/licenses/>.
--

--WARNGING: 20100721 drew Most of this code is the most broken. I've been
-- trying to balance getting these processes and functions to look and act
-- as much like arduino.cc's version of wiring as I can, while still writing
-- all of this in Occam, but that's mostly ending in this entire module
-- not compiling.
-- Work is ongoing.

--** occam bindings for the Wiring API.
--
-- @module wiring

#IF NOT (DEFINED (WIRING.MODULE))
#DEFINE WIRING.MODULE

#INCLUDE "avr.module"
#INCLUDE "boardmap.module"
#INCLUDE "digital.module"
#INCLUDE "printing.module"

--{{{  constants
VAL INT LOW IS #0:
VAL INT HIGH IS #1:

VAL INT INPUT IS #0:
VAL INT OUTPUT IS #1:

VAL INT DEFAULT IS #0:
VAL INT INTERNAL IS #1:
VAL INT EXTERNAL IS #2:


VAL INT SERIAL  IS #0:
VAL INT DISPLAY IS #1:

VAL INT LSBFIRST IS 0:
VAL INT MSBFIRST IS 1:

VAL INT CHANGE IS 1:
VAL INT FALLING IS 2:
VAL INT RISING IS 3:

VAL INT INTERNAL IS 3:
VAL INT DEFAULT IS 1:
VAL INT EXTERNAL IS 0:

--}}}


PROC pinMode (VAL INT board.pin, mode)
  INITIAL INT avr.pin IS board.to.chip(board.pin):
  --INT r.ddr, r.port, r.pin, bit:
  INT r.ddr, dummy1, dummy2, bit:
  SEQ
    --r.ddr, r.port, r.pin, bit := chip.to.gpio (avr.pin)
    r.ddr, dummy1, dummy2, bit := chip.to.gpio (avr.pin)
    pin.mode(r.ddr, bit, mode)
:

PROC digitalWrite (VAL INT board.pin, level)
  INITIAL INT avr.pin IS board.to.chip(board.pin):
  --INT r.ddr, r.port, r.pin, bit:
  INT dummy1, r.port, dummy2, bit:
  SEQ
    --r.ddr, r.port, r.pin, bit := chip.to.gpio (avr.pin)
    dummy1, r.port, dummy2, bit := chip.to.gpio (avr.pin)
    pin.write(r.port, bit, level)
:

INT FUNCTION digitalRead (VAL INT board.pin)
  VAL INT avr.pin IS board.to.chip(board.pin):
  --INT r.ddr, r.port, r.pin, bit:
  INT dummy1, dummy2, r.pin, bit, level:
  VALOF
    SEQ
      --r.ddr, r.port, r.pin, bit := chip.to.gpio (avr.pin)
      dummy1, dummy2, r.pin, bit := chip.to.gpio (avr.pin)
      pin.read(r.pin, bit, level)
    RESULT level
:

INT FUNCTION analogReference (VAL INT type)
  VALOF
    IF
      type = DEFAULT
        ADC.REF := DEFAULT
      type = INTERNAL
        ADC.REF := INTERNAL
      type = EXTERNAL
        ADC.REF := EXTERNAL
      TRUE
        die ("Analog processes do not support this type.")
    RESULT type
:

INT FUNCTION analogRead (VAL INT analog.pin)
  VAL INT avr.pin IS board.analog.to.chip(analog.pin):
  INT val:
  VALOF
    SEQ
      adc.base (avr.pin, ADC.REF, val)
    RESULT val
:

PROC analogWrite (VAL INT board.pin, VAL BYTE value) -- This is PWM, fyi
  INITIAL INT avr.pin IS board.analog.to.chip(board.pin):
  SEQ
    pwm8.setup (avr.pin, 64)
    pwm8.set.compare (avr.pin, value)
:

PROC Serial.begin (VAL INT32 speed)
  serial.start (TX0, speed)
:

PROC Serial.end ()
  --Stub function. We've never wanted to turn off serial, so this can get
  -- expanded when we figure out if we'll ever want to do it though plumbing.
  SKIP
:

INT FUNCTION Serial.available () IS (-1):
  --Another stub function that we've yet to impliment in plumbing.
  -- Might be worth looking into though? ::shrugs::

BYTE FUNCTION Serial.read ()
  BYTE b:
  VALOF
    serial.byte.in (RX0, b)
    RESULT b
:

PROC Serial.flush ()
  --More stubs that seem like they might be useful. I'm pretty sure Plumbing
  -- takes care of this for us though...
  SKIP
:

----So, this is my attempt to get what the arduino.cc crew does for their
---- serial.print (val, format), but I'm not sure it's possible in occam.
--PROC Serial.print (VAL INT val, VAL []BYTE format)
--  IF
--    format = ([]BYTE "BYTE")
--      serial.write.byte (TX0, (BYTE val))
--    format = ([]BYTE "BIN")
--      --We don't have support for printing binary strings atm
--      SKIP
--    format = ([]BYTE "OCT")
--      --Why would you even want this?
--      SKIP
--    format = ([]BYTE "DEC")
--      --Not sure if we can do this yet... I guess it would be real32s...
--      SKIP
--    format = ([]BYTE "HEX")
--      serial.write.int (TX0, val)
--    format = ([]BYTE "0"))
--      --Same as DEC.
--      SKIP
--    format = ([]BYTE "1")
--      --1 level of precision.
--      SKIP
--    format = ([]BYTE "2")
--      --2 levels of precision.
--      SKIP
--    format = ([]BYTE "3")
--      --I think you get the idea.
--      SKIP
--    format = ([]BYTE "4")
--      SKIP
--    format = ([]BYTE "5")
--      SKIP
--    format = ([]BYTE "6")
--      SKIP
--:
--
--PROC Serial.println (VAL INT val, VAL []BYTE format)
--  SEQ
--    Serial.print (val, format) --Note that this is the method above...
--    serial.write.newline (TX0) -- Whereas this is a printing.module PROC.
--:

PROC Serial.printByte (VAL BYTE val)
  serial.write.byte (TX0, val)
:

PROC Serial.printHex (VAL INT val)
  serial.write.int (TX0, val)
:

-- Because Method Overloading isn't a thing in Occam, I've decided this is
--  going to be exclusivly strings.
PROC Serial.write (VAL []BYTE string)
  serial.write.string (TX0, string)
:

--
----And we can't include Serial1:3 equivalents because R/TX1:3 are only
---- defined for the ATmega1280
--
--PROC Serial1.begin (VAL INT speed)
--  serial.start (TX1, speed)
--:
--
--PROC Serial1.end ()
--
--  SKIP
--:
--
--INT FUNCTION Serial1.available () IS (-1):
--
--BYTE FUNCTION Serial1.read ()
--  BYTE b:
--  VALOF
--    serial.byte.in (RX1, b)
--    RESULT b
--:
--
--PROC Serial1.flush ()
--  SKIP
--:
--PROC Serial1.printByte (VAL BYTE val)
--  serial.write.byte (TX1, val)
--:
--
--PROC Serial1.printHex (VAL BYTE val)
--  serial.write.int (TX1, val)
--:
--
--PROC Serial1.write (VAL []BYTE string)
--  serial.write.string (TX1, string)
--:
--
#ENDIF
