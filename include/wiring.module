--
--	Copyright (C) 2009-2010   Christian Jacobsen
--      Copyright (C) 2009-2010   Matt Jadud
--      Copyright (C)      2010   Michael Andrew Pirrone-Brusse
--      Copyright (C) 2009-2010   Adam Sampson
--
--	This library is free software; you can redistribute it and/or
--	modify it under the terms of the GNU Lesser General Public
--	License as published by the Free Software Foundation; either
--	version 2 of the License, or (at your option) any later version.
--
--	This library is distributed in the hope that it will be useful,
--	but WITHOUT ANY WARRANTY; without even the implied warranty of
--	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
--	Lesser General Public License for more details.
--
--      You should have received a copy of the GNU General Public License
--      along with this program.  If not, see <http://www.gnu.org/licenses/>.
--

--WARNGING: 20100718 drew None of this code works. It is all so much broken.
--  I think I'm going to go through in the coming week and make it less all bad

--** occam bindings for the Wiring API.
--
-- @module wiring

#IF NOT (DEFINED (WIRING.MODULE))
#DEFINE WIRING.MODULE

#INCLUDE "avr.module"
#INCLUDE "boardmap.module"
#INCLUDE "digital.module"
#INCLUDE "printing.module"
#INCLUDE "servo.module"

--{{{  constants
VAL INT LOW IS #0:
VAL INT HIGH IS #1:

VAL INT INPUT IS #0:
VAL INT OUTPUT IS #1:

--This is acting as a global variable. Does that even work in Occam?
INITIAL ADC.REF IS #0:

VAL INT DEFAULT IS #0:
VAL INT INTERNAL IS #1:
VAL INT EXTERNAL IS #2:


VAL INT SERIAL  IS #0:
VAL INT DISPLAY IS #1:

VAL INT LSBFIRST IS 0:
VAL INT MSBFIRST IS 1:

VAL INT CHANGE IS 1:
VAL INT FALLING IS 2:
VAL INT RISING IS 3:

VAL INT INTERNAL IS 3:
VAL INT DEFAULT IS 1:
VAL INT EXTERNAL IS 0:

--}}}


PROC pinMode (VAL INT board.pin, mode)
  INITIAL INT avr.pin IS board.to.chip(board.pin):
  --INT r.ddr, r.port, r.pin, bit:
  INT r.ddr, dummy1, dummy2, bit:
  SEQ
    --r.ddr, r.port, r.pin, bit := chip.to.gpio (avr.pin)
    r.ddr, dummy1, dummy2, bit := chip.to.gpio (avr.pin)
    pin.mode(r.ddr, bit, mode)
:

PROC digitalWrite (VAL INT board.pin, level)
  INITIAL INT avr.pin IS board.to.chip(board.pin):
  --INT r.ddr, r.port, r.pin, bit:
  INT dummy1, r.port, dummy2, bit:
  SEQ
    --r.ddr, r.port, r.pin, bit := chip.to.gpio (avr.pin)
    dummy1, r.port, dummy2, bit := chip.to.gpio (avr.pin)
    pin.write(r.port, bit, state)
:

INT FUNCTION digitalRead (VAL INT board.pin)
  INITIAL INT avr.pin IS board.to.chip(board.pin):
  --INT r.ddr, r.port, r.pin, bit:
  INT dummy1, dummy2, r.pin, bit, level:
  VALOF
    SEQ
      --r.ddr, r.port, r.pin, bit := chip.to.gpio (avr.pin)
      dummy1, dummy2, r.pin, bit := chip.to.gpio (avr.pin)
      pin.read(r.pin, bit, level)
  RESULT level
:

PROC analogReference (VAL INT type)
  IF
    type = DEFAULT
      ADC.REF := DEFAULT
    type = INTERNAL
      ADC.REF := INTERNAL
    type = EXTERNAL
      ADC.REF := EXTERNAL
    TRUE
      die ("Analog processes do not support this type.")
:

INT FUNCTION analogRead (VAL INT analog.pin)
  INITIAL INT avr.pin IS board.analog.to.chip(analog.pin):
  INITIAL INT val IS (-1):
  VALOF
    SEQ
      adc.base (avr.pin, ADC.REF, val)
  RESULT val
:

PROC analogWrite (VAL INT board.pin, VAL BYTE value) -- This is PWM, fyi
:

PROC Serial.begin (VAL INT speed)
:

PROC Serial.end ()
  --Stub function. We've never wanted to turn off serial, so this can get
  -- expanded when we figure out if we'll ever want to do it though plumbing.
  SKIP
:

INT FUNCTION Serial.available () IS 0:
  --Another stub function that we've yet to impliment in plumbing.
  -- Might be worth looking into though? ::shrugs::

BYTE FUNCTION Serial.read ()
:

PROC Serial.flush ()
  --More stubs that seem like they might be useful. I'm pretty sure Plumbing
  -- takes care of this for us though...
  SKIP
:

-- Well now... this is some seriously more complicated useability than we've
--  put in plumbing... I think I like the syntax though, and we'll be able to
--  support BYTE, HEX and... Almost Dec/0/2/4/ect. This reminds me I need to
--  figure out print.real32.
PROC Serial.print (VAL INT val, VAL []BYTE format)
:

PROC Serial.println (VAL INT val, VAL []BYTE format)
:

-- Because Method Overloading isn't a thing in Occam, I've decided this is
--  going to be exclusivly strings.
PROC Serial.write ()
:









--{{{  PROC beginSerial
--* Initialize serial port.
--
-- @para, port Serial port to initialize.
-- @param baud Baud rate.
PROC serialSetup (VAL INT port, VAL INT32 baud)
  serial.setup.blocking (port, baud)
:
--}}}

--{{{ PROC serialWriteByte
--* Write a byte to the serial port.
--
-- @param port Serial port to write to.
-- @param b Byte to write.
PROC serialWriteByte (VAL INT port, VAL BYTE b)
  serial.write.byte (port, b)
:
--}}}

--{{{  PROC serialWriteString
--* Write a string to the serial port.
--
-- @param port Serial port to write to.
-- @param string Bytes to write.
PROC serialWriteString (VAL INT port, VAL []BYTE string)
  SEQ i = 0 FOR SIZE string
    serial.write.byte (port, string[i])
:
--}}}

--{{{  PROC serialWriteInt
--* Write an [@code INT] to the serial port in hex.
--
-- @param port Serial port to write to.
-- @param n The integer to write.
PROC serialWriteInt (VAL INT port, VAL INT n)
  VAL []BYTE digits IS "0123456789abcdef":
  SEQ i = 3 FOR 4 STEP -1
    serial.write.byte (port, digits[(n >> (i * 4)) /\ #F])
:
--}}}

--{{{  PROC serialWriteInt32
--* Write an [@code INT32] to the serial port in hex.
--
-- @param port Serial port to write to.
-- @param n The long integer ([@code INT32]) to write.
PROC serialWriteInt32 (VAL INT port, VAL INT32 n)
  VAL []BYTE digits IS "0123456789abcdef":
  SEQ i = 7 FOR 8 STEP -1
    serial.write.byte (port, digits[INT ((n >> (i * 4)) /\ #F)])
:
--}}}

--{{{ PROC serialReadByte
--* Read a byte from the serial port.
--
-- @param port Serial port to read from.
-- @param b Byte to be read.
PROC serialReadByte (VAL INT port, RESULT BYTE b)
  serial.read.byte(port, b)
:
--}}}

#ENDIF
