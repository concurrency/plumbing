--** occam bindings for the Wiring API.
-- @module wiring

#IF NOT (DEFINED (WIRING.MODULE))
#DEFINE WIRING.MODULE

#INCLUDE "avr.module"
#INCLUDE "pinmapping.module"

--{{{  constants
DATA TYPE LEVEL IS INT
--* Symbolic constant for digital LOW on an Arduino pin.
VAL LEVEL LOW IS #0:
--* Symbolic constant for digital HIGH on an Arduino pin.
VAL LEVEL HIGH IS #1:

VAL INT INPUT IS #0:
VAL INT OUTPUT IS #1:

VAL INT SERIAL  IS #0:
VAL INT DISPLAY IS #1:

VAL INT LSBFIRST IS 0:
VAL INT MSBFIRST IS 1:

VAL INT CHANGE IS 1:
VAL INT FALLING IS 2:
VAL INT RISING IS 3:

VAL INT INTERNAL IS 3:
VAL INT DEFAULT IS 1:
VAL INT EXTERNAL IS 0:

--}}}

-- Most of the methods below are, at this point, pass-through methods.
-- Probably wants to change pretty soon, but this way neither wiring nor
--  plumbing are touching ports[..]

--{{{  PROC delay
--* Wait for a period of time.
-- @param millis Time in wait, in milliseconds
PROC delay (VAL INT millis)
  TIMER tim:
  INT t:
  SEQ
    tim ? t
    tim ? AFTER t PLUS millis
:
--}}}

--{{{  PROC digitalWrite
--* Sets the state of a pin to either HIGH or LOW.
-- @param pin The Arduino pin number.
-- @param state Either HIGH or LOW.
PROC digitalWrite (VAL INT pin, LEVEL state)
  INT r.ddr, r.port, r.pin, bit:
  PLACED [MAX.PORT]BYTE ports 0:
  #PRAGMA DEFINED ports
  SEQ
    r.ddr, r.port, r.pin, bit := pin.location (pin)
    ports[r.port] := (ports[r.port] /\ (~BV (bit))) \/ ((BYTE state) << bit)
:
--}}}

--{{{  PROC digitalRead
--* Read the value of a digital pin. Either HIGH or LOW.
-- @param pin The Arduino pin number.
-- @param state The state of the pin will be stored in this variable.
PROC digitalRead (VAL INT pin, RESULT INT state)
  INT r.ddr, r.port, r.pin, bit:
  PLACED [MAX.PORT]BYTE ports 0:
  #PRAGMA DEFINED ports
  SEQ
    r.ddr, r.port, r.pin, bit := pin.location (pin)
    state := (INT ((ports[r.pin] /\ (BV (bit))) >> bit))
:
--}}}

--{{{  PROC pinMode
PROC pinMode (VAL INT pin, mode)
  INT r.ddr, r.port, r.pin, bit:
  PLACED [MAX.PORT]BYTE ports 0:
  #PRAGMA DEFINED ports
  SEQ
    r.ddr, r.port, r.pin, bit := pin.location (pin)
    ports[r.ddr] := (ports[r.ddr] /\ (~BV (bit))) \/ ((BYTE mode) << bit)
:
--}}}

--{{{  PROC beginSerial
--* Initialize serial port.
--
-- @para, port Serial port to initialize.
-- @param baud Baud rate.
PROC beginSerial (VAL INT port, VAL INT32 baud)
  serial.setup.blocking (port, baud)
:
--}}}

--{{{ PROC serialWriteByte
--* Write a byte to the serial port.
--
-- @param port Serial port to write to.
-- @param b Byte to write.
PROC serialWriteByte (VAL INT port, VAL BYTE b)
  serial.write.byte (port, b)
:
--}}}

--{{{  PROC serialWriteString
--* Write a string to the serial port.
--
-- @param port Serial port to write to.
-- @param string Bytes to write.
PROC serialWriteString (VAL INT port, VAL []BYTE string)
  SEQ i = 0 FOR SIZE string
    serial.write.byte (port, string[i])
:
--}}}

--{{{  PROC serialWriteInt
--* Write an [@code INT] to the serial port in hex.
--
-- @param port Serial port to write to.
-- @param n The integer to write.
PROC serialWriteInt (VAL INT port, VAL INT n)
  VAL []BYTE digits IS "0123456789abcdef":
  SEQ i = 3 FOR 4 STEP -1
    serial.write.byte (port, digits[(n >> (i * 4)) /\ #F])
:
--}}}

--{{{  PROC serialWriteInt32
--* Write an [@code INT32] to the serial port in hex.
--
-- @param port Serial port to write to.
-- @param n The long integer ([@code INT32]) to write.
PROC serialWriteInt32 (VAL INT port, VAL INT32 n)
  VAL []BYTE digits IS "0123456789abcdef":
  SEQ i = 7 FOR 8 STEP -1
    serial.write.byte (0, digits[INT ((n >> (i * 4)) /\ #F)])
:
--}}}

--{{{ PROC serialReadByte
--* Read a byte from the serial port.
--
-- @param port Serial port to read from.
-- @param b Byte to be read.
PROC serialReadByte (VAL INT port, RESULT BYTE b)
  serial.read.byte(port, b)
:
--}}}

#ENDIF
